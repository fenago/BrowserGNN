<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BrowserGNN Training Dashboard</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      color: #e0e0e0;
    }

    .dashboard {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 20px 0 30px;
    }

    header h1 {
      font-size: 2.5em;
      background: linear-gradient(90deg, #00d4ff, #7c3aed, #f472b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    header p {
      color: #9ca3af;
      margin-top: 10px;
    }

    .grid {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: 20px;
    }

    .panel {
      background: rgba(30, 41, 59, 0.8);
      border-radius: 16px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .panel h2 {
      font-size: 1.2em;
      margin-bottom: 15px;
      color: #60a5fa;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel h2::before {
      content: '';
      width: 4px;
      height: 20px;
      background: #60a5fa;
      border-radius: 2px;
    }

    /* Control Panel */
    .control-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .form-group label {
      font-size: 0.85em;
      color: #9ca3af;
    }

    .form-group input, .form-group select {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px 12px;
      color: #e0e0e0;
      font-size: 0.95em;
    }

    .form-group input:focus, .form-group select:focus {
      outline: none;
      border-color: #60a5fa;
    }

    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }

    .btn-success {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-group {
      display: flex;
      gap: 10px;
    }

    .btn-group .btn {
      flex: 1;
    }

    /* Stats */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 10px;
    }

    .stat-card {
      background: rgba(15, 23, 42, 0.6);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }

    .stat-value {
      font-size: 1.8em;
      font-weight: bold;
      background: linear-gradient(90deg, #10b981, #3b82f6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-label {
      font-size: 0.8em;
      color: #9ca3af;
      margin-top: 4px;
    }

    /* Main Content Area */
    .main-content {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Charts */
    .charts-row {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
    }

    .chart-container {
      height: 280px;
      position: relative;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    /* Graph Visualization */
    .graph-viz {
      height: 350px;
      position: relative;
    }

    #graphCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.6);
      cursor: crosshair;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(96, 165, 250, 0.5);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 0.85em;
      color: #e0e0e0;
      pointer-events: none;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      max-width: 250px;
    }

    .tooltip-title {
      font-weight: bold;
      color: #60a5fa;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 4px;
    }

    .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      margin-top: 4px;
    }

    .tooltip-label {
      color: #9ca3af;
    }

    .tooltip-value {
      font-weight: 500;
    }

    .tooltip-correct {
      color: #10b981;
    }

    .tooltip-incorrect {
      color: #ef4444;
    }

    /* Log Panel */
    .log-panel {
      background: rgba(15, 23, 42, 0.6);
      border-radius: 8px;
      padding: 15px;
      height: 200px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.85em;
    }

    .log-entry {
      padding: 4px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .log-entry.info { color: #60a5fa; }
    .log-entry.success { color: #10b981; }
    .log-entry.warning { color: #f59e0b; }
    .log-entry.error { color: #ef4444; }

    /* Dataset selector */
    .dataset-cards {
      display: flex;
      gap: 10px;
      margin: 10px 0;
    }

    .dataset-card {
      flex: 1;
      background: rgba(15, 23, 42, 0.6);
      border: 2px solid transparent;
      border-radius: 10px;
      padding: 12px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
    }

    .dataset-card:hover {
      border-color: rgba(96, 165, 250, 0.5);
    }

    .dataset-card.selected {
      border-color: #60a5fa;
      background: rgba(59, 130, 246, 0.1);
    }

    .dataset-card h4 {
      font-size: 0.95em;
      color: #e0e0e0;
    }

    .dataset-card p {
      font-size: 0.75em;
      color: #9ca3af;
      margin-top: 4px;
    }

    /* Progress bar */
    .progress-container {
      margin: 15px 0;
    }

    .progress-bar {
      height: 6px;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #10b981, #3b82f6);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .progress-fill.complete {
      background: linear-gradient(90deg, #10b981, #059669);
    }

    .progress-fill.stopped {
      background: linear-gradient(90deg, #f59e0b, #d97706);
    }

    .progress-text {
      font-size: 0.8em;
      color: #9ca3af;
      margin-top: 6px;
      text-align: center;
    }

    .progress-text.complete {
      color: #10b981;
      font-weight: 600;
    }

    .progress-text.stopped {
      color: #f59e0b;
      font-weight: 600;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 15px;
    }

    .tab {
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.6);
      border: none;
      color: #9ca3af;
      cursor: pointer;
      border-radius: 6px;
      font-size: 0.9em;
      transition: all 0.2s;
    }

    .tab:hover {
      color: #e0e0e0;
    }

    .tab.active {
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .charts-row {
        grid-template-columns: 1fr;
      }
    }

    /* Legend */
    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85em;
      color: #9ca3af;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    /* CSV Upload */
    .csv-upload-area {
      border: 2px dashed rgba(96, 165, 250, 0.4);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      margin-top: 12px;
      transition: all 0.2s;
      cursor: pointer;
      display: none;
    }

    .csv-upload-area.visible {
      display: block;
    }

    .csv-upload-area:hover, .csv-upload-area.dragover {
      border-color: #60a5fa;
      background: rgba(59, 130, 246, 0.1);
    }

    .csv-upload-area input[type="file"] {
      display: none;
    }

    .csv-upload-icon {
      font-size: 2em;
      margin-bottom: 8px;
    }

    .csv-upload-text {
      font-size: 0.85em;
      color: #9ca3af;
    }

    .csv-upload-text strong {
      color: #60a5fa;
    }

    .csv-info {
      font-size: 0.75em;
      color: #6b7280;
      margin-top: 8px;
    }

    .loaded-dataset-info {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 8px;
      padding: 10px;
      margin-top: 10px;
      font-size: 0.85em;
      display: none;
    }

    .loaded-dataset-info.visible {
      display: block;
    }

    .loaded-dataset-info .dataset-name {
      color: #10b981;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="dashboard">
    <header>
      <h1>BrowserGNN Training Dashboard</h1>
      <p>Real-time Graph Neural Network Training in Your Browser</p>
    </header>

    <div class="grid">
      <!-- Control Panel -->
      <div class="control-panel">
        <div class="panel">
          <h2>Dataset</h2>
          <div class="dataset-cards">
            <div class="dataset-card selected" data-dataset="karate">
              <h4>Karate Club</h4>
              <p>34 nodes, 2 classes</p>
            </div>
            <div class="dataset-card" data-dataset="custom">
              <h4>Custom CSV</h4>
              <p>Upload your own</p>
            </div>
          </div>
          <div class="csv-upload-area" id="csvUploadArea">
            <div class="csv-upload-icon">üìÅ</div>
            <div class="csv-upload-text">
              <strong>Click to upload</strong> or drag & drop<br>
              CSV files (edges, features, labels)
            </div>
            <div class="csv-info">
              Format: edges.csv (src,dst), features.csv (one row per node), labels.csv (class per node)
            </div>
            <input type="file" id="csvFileInput" accept=".csv" multiple>
          </div>
          <div class="loaded-dataset-info" id="loadedDatasetInfo">
            <span class="dataset-name" id="customDatasetName">custom-dataset</span>
            <span id="customDatasetStats"></span>
          </div>
          <div class="form-group">
            <label>Train/Val Split</label>
            <input type="range" id="trainSplit" min="0.1" max="0.9" step="0.1" value="0.7">
            <span id="splitText">70% train / 30% val</span>
          </div>
        </div>

        <div class="panel">
          <h2>Model Architecture</h2>
          <div class="form-group">
            <label>GNN Layer Type</label>
            <select id="layerType">
              <option value="gcn">GCN (Graph Convolutional)</option>
              <option value="sage">GraphSAGE</option>
              <option value="gat">GAT (Graph Attention)</option>
            </select>
          </div>
          <div class="form-group">
            <label>Hidden Channels</label>
            <input type="number" id="hiddenChannels" value="16" min="4" max="256">
          </div>
          <div class="form-group">
            <label>Number of Layers</label>
            <select id="numLayers">
              <option value="2" selected>2 Layers</option>
              <option value="3">3 Layers</option>
              <option value="4">4 Layers</option>
            </select>
          </div>
          <div class="form-group">
            <label>Dropout</label>
            <input type="number" id="dropout" value="0.5" min="0" max="0.9" step="0.1">
          </div>
        </div>

        <div class="panel">
          <h2>Training Parameters</h2>
          <div class="form-group">
            <label>Optimizer</label>
            <select id="optimizer">
              <option value="adam" selected>Adam</option>
              <option value="sgd">SGD</option>
              <option value="rmsprop">RMSprop</option>
            </select>
          </div>
          <div class="form-group">
            <label>Learning Rate</label>
            <input type="number" id="learningRate" value="0.01" min="0.0001" max="1" step="0.001">
          </div>
          <div class="form-group">
            <label>Weight Decay</label>
            <input type="number" id="weightDecay" value="0.0005" min="0" max="0.1" step="0.0001">
          </div>
          <div class="form-group">
            <label>Max Epochs</label>
            <input type="number" id="maxEpochs" value="200" min="10" max="1000">
          </div>
          <div class="form-group">
            <label>Early Stopping Patience</label>
            <input type="number" id="patience" value="20" min="5" max="100">
          </div>
        </div>

        <div class="panel">
          <h2>Training Control</h2>
          <div class="progress-container">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Ready to train</div>
          </div>
          <div class="btn-group">
            <button class="btn btn-primary" id="trainBtn">
              <span>Start Training</span>
            </button>
            <button class="btn btn-danger" id="stopBtn" disabled>
              <span>Stop</span>
            </button>
          </div>
          <button class="btn btn-success" id="resetBtn" style="margin-top: 10px; width: 100%;">
            <span>Reset Model</span>
          </button>
        </div>

        <div class="panel">
          <h2>Current Metrics</h2>
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" id="currentEpoch">0</div>
              <div class="stat-label">Epoch</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="currentLoss">-</div>
              <div class="stat-label">Loss</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="trainAcc">-</div>
              <div class="stat-label">Train Acc</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="valAcc">-</div>
              <div class="stat-label">Val Acc</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <div class="charts-row">
          <div class="panel">
            <h2>Loss Curves</h2>
            <div class="chart-container">
              <canvas id="lossChart"></canvas>
            </div>
            <div class="legend">
              <div class="legend-item">
                <div class="legend-dot" style="background: #3b82f6;"></div>
                <span>Train Loss</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #f97316;"></div>
                <span>Val Loss</span>
              </div>
            </div>
          </div>
          <div class="panel">
            <h2>Accuracy Curves</h2>
            <div class="chart-container">
              <canvas id="accChart"></canvas>
            </div>
            <div class="legend">
              <div class="legend-item">
                <div class="legend-dot" style="background: #10b981;"></div>
                <span>Train Accuracy</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #ec4899;"></div>
                <span>Val Accuracy</span>
              </div>
            </div>
          </div>
        </div>

        <div class="panel">
          <h2>Graph Visualization</h2>
          <div class="tabs">
            <button class="tab active" data-view="graph">Graph Structure</button>
            <button class="tab" data-view="predictions">Predictions</button>
            <button class="tab" data-view="embeddings">Embeddings (t-SNE)</button>
          </div>
          <div class="graph-viz">
            <canvas id="graphCanvas"></canvas>
            <div class="tooltip" id="tooltip"></div>
          </div>
        </div>

        <div class="panel">
          <h2>Training Log</h2>
          <div class="log-panel" id="logPanel">
            <div class="log-entry info">[System] BrowserGNN Training Dashboard initialized</div>
            <div class="log-entry info">[System] Select a dataset and click "Start Training" to begin</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // Import BrowserGNN
    import {
      Tensor,
      GraphData,
      GCNConv,
      GATConv,
      SAGEConv,
      Variable,
      Adam,
      SGD,
      RMSprop,
      crossEntropyLoss,
      MessagePassing,
      computeGCNNorm,
    } from 'browser-gnn';

    // State
    let isTraining = false;
    let stopRequested = false;
    let currentDataset = 'karate';
    let graphData = null;
    let labels = null;
    let trainMask = [];
    let valMask = [];
    let model = null;
    let optimizer = null;
    let lossHistory = [];
    let valLossHistory = [];
    let accHistory = [];
    let valAccHistory = [];
    let nodePositions = [];
    let currentView = 'graph'; // 'graph', 'predictions', 'embeddings'
    let currentEmbeddings = null; // Store embeddings for visualization
    let currentPredictions = []; // Store predictions
    let tsnePositions = []; // Store t-SNE computed positions

    // DOM elements
    const trainBtn = document.getElementById('trainBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const logPanel = document.getElementById('logPanel');
    const lossCanvas = document.getElementById('lossChart');
    const accCanvas = document.getElementById('accChart');
    const graphCanvas = document.getElementById('graphCanvas');
    const tooltip = document.getElementById('tooltip');

    // Chart contexts
    const lossCtx = lossCanvas.getContext('2d');
    const accCtx = accCanvas.getContext('2d');
    const graphCtx = graphCanvas.getContext('2d');

    // Karate Club dataset
    function loadKarateClub() {
      // Zachary's Karate Club graph
      const edges = [
        [0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,10],[0,11],[0,12],[0,13],[0,17],[0,19],[0,21],[0,31],
        [1,2],[1,3],[1,7],[1,13],[1,17],[1,19],[1,21],[1,30],
        [2,3],[2,7],[2,8],[2,9],[2,13],[2,27],[2,28],[2,32],
        [3,7],[3,12],[3,13],
        [4,6],[4,10],
        [5,6],[5,10],[5,16],
        [6,16],
        [8,30],[8,32],[8,33],
        [9,33],
        [13,33],
        [14,32],[14,33],
        [15,32],[15,33],
        [18,32],[18,33],
        [19,33],
        [20,32],[20,33],
        [22,32],[22,33],
        [23,25],[23,27],[23,29],[23,32],[23,33],
        [24,25],[24,27],[24,31],
        [25,31],
        [26,29],[26,33],
        [27,33],
        [28,31],[28,33],
        [29,32],[29,33],
        [30,32],[30,33],
        [31,32],[31,33],
        [32,33]
      ];

      const numNodes = 34;
      const numEdges = edges.length * 2; // Undirected

      // Create edge index (source and target arrays)
      const edgeIndex = new Uint32Array(numEdges * 2);
      let idx = 0;
      for (const [src, dst] of edges) {
        edgeIndex[idx] = src;
        edgeIndex[numEdges + idx] = dst;
        idx++;
        edgeIndex[idx] = dst;
        edgeIndex[numEdges + idx] = src;
        idx++;
      }

      // Node features: one-hot encoding of node ID
      const features = new Float32Array(numNodes * numNodes);
      for (let i = 0; i < numNodes; i++) {
        features[i * numNodes + i] = 1;
      }

      // Labels: club membership (0 = Mr. Hi, 1 = Officer)
      const nodeLabels = new Uint32Array([
        0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1
      ]);

      graphData = new GraphData({
        x: features,
        edgeIndex,
        numNodes,
        numFeatures: numNodes,
        numEdges,
      });

      labels = nodeLabels;

      // Generate node positions using force-directed layout
      generateNodePositions(edges, numNodes);

      log('info', `Loaded Karate Club: ${numNodes} nodes, ${edges.length} edges, 2 classes`);

      return { numNodes, numFeatures: numNodes, numClasses: 2 };
    }

    // Custom CSV dataset variables
    let customDatasetEdges = [];

    // CSV parsing and loading functions
    async function handleCSVFiles(files) {
      log('info', `Processing ${files.length} CSV file(s)...`);

      const fileContents = {};
      for (const file of files) {
        const name = file.name.toLowerCase();
        const content = await readFileAsText(file);
        fileContents[name] = content;
      }

      try {
        // Parse the CSV files
        const result = parseCSVDataset(fileContents);

        // Update global graph data
        graphData = result.graphData;
        labels = result.labels;
        customDatasetEdges = result.edges;

        // Generate positions for visualization
        generateNodePositions(result.edges, result.numNodes);

        // Update UI
        const loadedInfo = document.getElementById('loadedDatasetInfo');
        const datasetName = document.getElementById('customDatasetName');
        const datasetStats = document.getElementById('customDatasetStats');

        datasetName.textContent = files[0].name.replace('.csv', '');
        datasetStats.textContent = ` - ${result.numNodes} nodes, ${result.edges.length} edges, ${result.numClasses} classes`;
        loadedInfo.classList.add('visible');

        // Reset predictions
        currentEmbeddings = null;
        currentPredictions = [];
        tsnePositions = [];

        // Redraw visualization
        drawVisualization();

        log('success', `Loaded custom dataset: ${result.numNodes} nodes, ${result.edges.length} edges, ${result.numClasses} classes`);
      } catch (error) {
        log('error', `Failed to parse CSV: ${error.message}`);
      }
    }

    function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = (e) => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    }

    function parseCSVDataset(fileContents) {
      // Try to auto-detect file type based on name or content
      let edgesData = null;
      let featuresData = null;
      let labelsData = null;

      // Check for specific filenames
      for (const [filename, content] of Object.entries(fileContents)) {
        if (filename.includes('edge')) {
          edgesData = parseCSV(content);
        } else if (filename.includes('feature') || filename.includes('node')) {
          featuresData = parseCSV(content);
        } else if (filename.includes('label') || filename.includes('class')) {
          labelsData = parseCSV(content);
        }
      }

      // If only one file, try to detect format
      if (Object.keys(fileContents).length === 1) {
        const content = Object.values(fileContents)[0];
        return parseUnifiedCSV(content);
      }

      // Build graph from separate files
      if (!edgesData) {
        throw new Error('No edges file found. Expected file with "edge" in filename.');
      }

      // Parse edges
      const edges = [];
      const hasHeader = isNaN(parseInt(edgesData[0][0]));
      const startIdx = hasHeader ? 1 : 0;

      for (let i = startIdx; i < edgesData.length; i++) {
        const row = edgesData[i];
        if (row.length >= 2) {
          const src = parseInt(row[0]);
          const dst = parseInt(row[1]);
          if (!isNaN(src) && !isNaN(dst)) {
            edges.push([src, dst]);
          }
        }
      }

      // Determine number of nodes
      let numNodes = 0;
      for (const [src, dst] of edges) {
        numNodes = Math.max(numNodes, src + 1, dst + 1);
      }

      // Parse features or create default one-hot
      let features;
      let numFeatures;
      if (featuresData && featuresData.length > 0) {
        const hasHeaderF = isNaN(parseFloat(featuresData[0][0]));
        const startIdxF = hasHeaderF ? 1 : 0;
        numFeatures = featuresData[startIdxF].length;
        features = new Float32Array(numNodes * numFeatures);

        for (let i = startIdxF; i < featuresData.length && (i - startIdxF) < numNodes; i++) {
          const row = featuresData[i];
          for (let f = 0; f < numFeatures; f++) {
            features[(i - startIdxF) * numFeatures + f] = parseFloat(row[f]) || 0;
          }
        }
      } else {
        // Default to one-hot encoding
        numFeatures = numNodes;
        features = new Float32Array(numNodes * numNodes);
        for (let i = 0; i < numNodes; i++) {
          features[i * numNodes + i] = 1;
        }
      }

      // Parse labels
      let nodeLabels;
      let numClasses = 2;
      if (labelsData && labelsData.length > 0) {
        const hasHeaderL = isNaN(parseInt(labelsData[0][0]));
        const startIdxL = hasHeaderL ? 1 : 0;
        nodeLabels = new Uint32Array(numNodes);
        const labelSet = new Set();

        for (let i = startIdxL; i < labelsData.length && (i - startIdxL) < numNodes; i++) {
          const label = parseInt(labelsData[i][0]) || 0;
          nodeLabels[i - startIdxL] = label;
          labelSet.add(label);
        }
        numClasses = labelSet.size;
      } else {
        // Default to random 2-class labels
        nodeLabels = new Uint32Array(numNodes);
        for (let i = 0; i < numNodes; i++) {
          nodeLabels[i] = Math.random() < 0.5 ? 0 : 1;
        }
      }

      // Create edge index (undirected)
      const numEdges = edges.length * 2;
      const edgeIndex = new Uint32Array(numEdges * 2);
      let idx = 0;
      for (const [src, dst] of edges) {
        edgeIndex[idx] = src;
        edgeIndex[numEdges + idx] = dst;
        idx++;
        edgeIndex[idx] = dst;
        edgeIndex[numEdges + idx] = src;
        idx++;
      }

      const graphDataResult = new GraphData({
        x: features,
        edgeIndex,
        numNodes,
        numFeatures,
        numEdges,
      });

      return {
        graphData: graphDataResult,
        labels: nodeLabels,
        edges,
        numNodes,
        numFeatures,
        numClasses
      };
    }

    function parseUnifiedCSV(content) {
      // Parse a unified CSV format where each row is:
      // node_id, feature1, feature2, ..., label, neighbor1, neighbor2, ...
      // OR just edges: src, dst
      const data = parseCSV(content);
      if (data.length === 0) {
        throw new Error('Empty CSV file');
      }

      // Check if it's just edges (2 columns of integers)
      if (data[0].length === 2 && !isNaN(parseInt(data[0][0])) && !isNaN(parseInt(data[0][1]))) {
        // Edges only format
        const edges = [];
        for (const row of data) {
          const src = parseInt(row[0]);
          const dst = parseInt(row[1]);
          if (!isNaN(src) && !isNaN(dst)) {
            edges.push([src, dst]);
          }
        }

        let numNodes = 0;
        for (const [src, dst] of edges) {
          numNodes = Math.max(numNodes, src + 1, dst + 1);
        }

        // Create default features and labels
        const features = new Float32Array(numNodes * numNodes);
        for (let i = 0; i < numNodes; i++) {
          features[i * numNodes + i] = 1;
        }

        const nodeLabels = new Uint32Array(numNodes);
        for (let i = 0; i < numNodes; i++) {
          nodeLabels[i] = Math.random() < 0.5 ? 0 : 1;
        }

        const numEdges = edges.length * 2;
        const edgeIndex = new Uint32Array(numEdges * 2);
        let idx = 0;
        for (const [src, dst] of edges) {
          edgeIndex[idx] = src;
          edgeIndex[numEdges + idx] = dst;
          idx++;
          edgeIndex[idx] = dst;
          edgeIndex[numEdges + idx] = src;
          idx++;
        }

        return {
          graphData: new GraphData({
            x: features,
            edgeIndex,
            numNodes,
            numFeatures: numNodes,
            numEdges,
          }),
          labels: nodeLabels,
          edges,
          numNodes,
          numFeatures: numNodes,
          numClasses: 2
        };
      }

      throw new Error('Unrecognized CSV format. Please provide separate edges.csv, features.csv, and labels.csv files.');
    }

    function parseCSV(content) {
      const lines = content.trim().split('\n');
      return lines.map(line => line.split(',').map(cell => cell.trim()));
    }

    function generateNodePositions(edges, numNodes) {
      // Simple force-directed layout
      nodePositions = [];
      for (let i = 0; i < numNodes; i++) {
        nodePositions.push({
          x: Math.random() * 0.8 + 0.1,
          y: Math.random() * 0.8 + 0.1,
          vx: 0,
          vy: 0
        });
      }

      // Run simulation
      for (let iter = 0; iter < 100; iter++) {
        // Repulsion between all nodes
        for (let i = 0; i < numNodes; i++) {
          for (let j = i + 1; j < numNodes; j++) {
            const dx = nodePositions[j].x - nodePositions[i].x;
            const dy = nodePositions[j].y - nodePositions[i].y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
            const force = 0.001 / (dist * dist);
            nodePositions[i].vx -= dx / dist * force;
            nodePositions[i].vy -= dy / dist * force;
            nodePositions[j].vx += dx / dist * force;
            nodePositions[j].vy += dy / dist * force;
          }
        }

        // Attraction along edges
        for (const [src, dst] of edges) {
          const dx = nodePositions[dst].x - nodePositions[src].x;
          const dy = nodePositions[dst].y - nodePositions[src].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const force = dist * 0.1;
          nodePositions[src].vx += dx * force;
          nodePositions[src].vy += dy * force;
          nodePositions[dst].vx -= dx * force;
          nodePositions[dst].vy -= dy * force;
        }

        // Update positions
        for (let i = 0; i < numNodes; i++) {
          nodePositions[i].x += nodePositions[i].vx;
          nodePositions[i].y += nodePositions[i].vy;
          nodePositions[i].vx *= 0.9;
          nodePositions[i].vy *= 0.9;
          // Keep in bounds
          nodePositions[i].x = Math.max(0.1, Math.min(0.9, nodePositions[i].x));
          nodePositions[i].y = Math.max(0.1, Math.min(0.9, nodePositions[i].y));
        }
      }
    }

    function createMasks(numNodes, trainRatio) {
      const indices = Array.from({ length: numNodes }, (_, i) => i);
      // Shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }

      const numTrain = Math.floor(numNodes * trainRatio);
      trainMask = new Array(numNodes).fill(false);
      valMask = new Array(numNodes).fill(false);

      for (let i = 0; i < numTrain; i++) {
        trainMask[indices[i]] = true;
      }
      for (let i = numTrain; i < numNodes; i++) {
        valMask[indices[i]] = true;
      }

      log('info', `Split: ${numTrain} train, ${numNodes - numTrain} validation`);
    }

    function createModel(config) {
      const { layerType, hiddenChannels, numLayers, numFeatures, numClasses, dropout } = config;

      class GNNModel {
        constructor() {
          this.layers = [];
          this.dropoutRate = dropout;

          // Create layers
          const Layer = layerType === 'gcn' ? GCNConv :
                       layerType === 'gat' ? GATConv : SAGEConv;

          // First layer
          this.layers.push(new Layer({
            inChannels: numFeatures,
            outChannels: hiddenChannels,
            ...(layerType === 'gat' ? { heads: 8, dropout: dropout } : {})
          }));

          // Hidden layers
          const hiddenIn = layerType === 'gat' ? hiddenChannels * 8 : hiddenChannels;
          for (let i = 1; i < numLayers - 1; i++) {
            this.layers.push(new Layer({
              inChannels: hiddenIn,
              outChannels: hiddenChannels,
              ...(layerType === 'gat' ? { heads: 8, dropout: dropout } : {})
            }));
          }

          // Output layer
          const lastIn = layerType === 'gat' ? hiddenChannels * 8 : hiddenChannels;
          this.layers.push(new Layer({
            inChannels: lastIn,
            outChannels: numClasses,
            ...(layerType === 'gat' ? { heads: 1, concat: false, dropout: dropout } : {})
          }));

          // Create trainable variables for weights
          this.variables = [];
          this.layerVariables = []; // Track per-layer for forwardWithGrad
          for (const layer of this.layers) {
            const layerVars = {};
            const params = layer._parameters;
            for (const [name, param] of params) {
              const v = new Variable(param.tensor, { requiresGrad: true, name: `${this.layers.indexOf(layer)}_${name}` });
              this.variables.push(v);
              layerVars[name] = v;
            }
            this.layerVariables.push(layerVars);
          }

          // Store layer configs for forwardWithGrad
          this.layerConfigs = this.layers.map(layer => ({
            inChannels: layer.inChannels,
            outChannels: layer.outChannels,
            addSelfLoops: layer.addSelfLoops,
            normalize: layer.normalize,
            useBias: layer.useBias
          }));
        }

        forward(graph) {
          let out = graph;
          for (let i = 0; i < this.layers.length; i++) {
            out = this.layers[i].forward(out);
            // Apply ReLU to all but last layer
            if (i < this.layers.length - 1) {
              const reluData = new Float32Array(out.x.size);
              for (let j = 0; j < out.x.size; j++) {
                reluData[j] = Math.max(0, out.x.data[j]);
              }
              out = out.withFeatures(new Tensor(reluData, out.x.shape));
            }
          }
          return out;
        }

        // Forward pass with gradient tracking using Variables
        forwardWithGrad(graph) {
          const { x, edgeIndex, numEdges, numNodes } = graph;

          // Wrap input features as Variable
          let hVar = new Variable(x, { requiresGrad: false, name: 'input' });

          for (let layerIdx = 0; layerIdx < this.layers.length; layerIdx++) {
            const layerVars = this.layerVariables[layerIdx];
            const config = this.layerConfigs[layerIdx];
            const weightVar = layerVars.weight;
            const biasVar = layerVars.bias;

            // Process graph (add self-loops if needed)
            let processedGraph = graph;
            if (config.addSelfLoops && !graph.hasSelfLoops()) {
              processedGraph = graph.addSelfLoops();
            }

            // Step 1: Linear transform: H_transformed = X @ W (using Variables)
            const transformedVar = hVar.matmul(weightVar);

            // Step 2: Message passing (GCN normalization)
            // This is a fixed linear operation - no learnable params
            // We compute it with Tensors and wrap as Variable
            const transformed = transformedVar.data;
            let aggregated;

            if (config.normalize) {
              // Compute GCN normalization coefficients
              const norm = computeGCNNorm(
                processedGraph.edgeIndex,
                processedGraph.numEdges,
                numNodes,
                false
              );

              // Gather source features
              const srcFeatures = MessagePassing.gather(
                transformed,
                processedGraph.edgeIndex.slice(0, processedGraph.numEdges)
              );

              // Apply normalization
              const normalizedMessages = new Float32Array(srcFeatures.size);
              for (let i = 0; i < processedGraph.numEdges; i++) {
                for (let f = 0; f < config.outChannels; f++) {
                  normalizedMessages[i * config.outChannels + f] =
                    srcFeatures.data[i * config.outChannels + f] * norm[i];
                }
              }
              const normalizedTensor = new Tensor(normalizedMessages, srcFeatures.shape);

              // Scatter-add to target nodes
              aggregated = MessagePassing.scatterAdd(
                normalizedTensor,
                processedGraph.edgeIndex.slice(processedGraph.numEdges),
                numNodes
              );
            } else {
              // Simple sum without normalization
              const srcFeatures = MessagePassing.gather(
                transformed,
                processedGraph.edgeIndex.slice(0, processedGraph.numEdges)
              );
              aggregated = MessagePassing.scatterAdd(
                srcFeatures,
                processedGraph.edgeIndex.slice(processedGraph.numEdges),
                numNodes
              );
            }

            // Wrap aggregated result as Variable (connecting to transformedVar's graph)
            // The gradient will flow: aggregated -> transformed -> weight
            // We need to create this connection manually using a custom backward
            const aggregatedVar = new Variable(aggregated, {
              requiresGrad: true,
              gradNode: {
                inputs: [transformedVar],
                backward: (grad) => {
                  // Backward through scatter-add is gather
                  // Backward through gather is scatter-add
                  // For GCN: d/d(transformed) = aggregate^T(grad)
                  const gradData = new Float32Array(transformed.size);

                  if (config.normalize) {
                    const norm = computeGCNNorm(
                      processedGraph.edgeIndex,
                      processedGraph.numEdges,
                      numNodes,
                      false
                    );

                    // Scatter grad back to source nodes (reverse of gather)
                    for (let e = 0; e < processedGraph.numEdges; e++) {
                      const src = processedGraph.edgeIndex[e];
                      const dst = processedGraph.edgeIndex[processedGraph.numEdges + e];
                      for (let f = 0; f < config.outChannels; f++) {
                        gradData[src * config.outChannels + f] +=
                          grad.data[dst * config.outChannels + f] * norm[e];
                      }
                    }
                  } else {
                    for (let e = 0; e < processedGraph.numEdges; e++) {
                      const src = processedGraph.edgeIndex[e];
                      const dst = processedGraph.edgeIndex[processedGraph.numEdges + e];
                      for (let f = 0; f < config.outChannels; f++) {
                        gradData[src * config.outChannels + f] +=
                          grad.data[dst * config.outChannels + f];
                      }
                    }
                  }

                  return [new Tensor(gradData, transformed.shape)];
                },
                name: 'gcn_aggregate'
              },
              name: `layer${layerIdx}_agg`
            });

            // Step 3: Add bias (using Variables)
            let outputVar;
            if (config.useBias && biasVar) {
              // Broadcast bias to all nodes
              const biasData = new Float32Array(numNodes * config.outChannels);
              for (let n = 0; n < numNodes; n++) {
                for (let f = 0; f < config.outChannels; f++) {
                  biasData[n * config.outChannels + f] = biasVar.data.data[f];
                }
              }
              const biasBroadcast = new Variable(new Tensor(biasData, [numNodes, config.outChannels]), {
                requiresGrad: true,
                gradNode: {
                  inputs: [biasVar],
                  backward: (grad) => {
                    // Sum gradient over all nodes to get bias gradient
                    const biasGrad = new Float32Array(config.outChannels);
                    for (let n = 0; n < numNodes; n++) {
                      for (let f = 0; f < config.outChannels; f++) {
                        biasGrad[f] += grad.data[n * config.outChannels + f];
                      }
                    }
                    return [new Tensor(biasGrad, [config.outChannels])];
                  },
                  name: 'bias_broadcast'
                },
                name: `layer${layerIdx}_bias_broadcast`
              });
              outputVar = aggregatedVar.add(biasBroadcast);
            } else {
              outputVar = aggregatedVar;
            }

            // Step 4: Apply ReLU (except last layer)
            if (layerIdx < this.layers.length - 1) {
              hVar = outputVar.relu();
            } else {
              hVar = outputVar;
            }
          }

          // Return both the GraphData (for visualization) and the Variable (for backward)
          return {
            graph: graph.withFeatures(hVar.data),
            outputVar: hVar
          };
        }

        getVariables() {
          return this.variables;
        }
      }

      return new GNNModel();
    }

    function createOptimizer(model, config) {
      const variables = model.getVariables();
      const { optimizer: optType, learningRate, weightDecay } = config;

      switch (optType) {
        case 'adam':
          return new Adam(variables, { lr: learningRate, weightDecay });
        case 'sgd':
          return new SGD(variables, { lr: learningRate, weightDecay, momentum: 0.9 });
        case 'rmsprop':
          return new RMSprop(variables, { lr: learningRate, weightDecay });
        default:
          return new Adam(variables, { lr: learningRate, weightDecay });
      }
    }

    async function train() {
      if (isTraining) return;

      isTraining = true;
      stopRequested = false;
      trainBtn.disabled = true;
      stopBtn.disabled = false;

      // Clear history
      lossHistory = [];
      valLossHistory = [];
      accHistory = [];
      valAccHistory = [];

      // Get config
      const config = {
        layerType: document.getElementById('layerType').value,
        hiddenChannels: parseInt(document.getElementById('hiddenChannels').value),
        numLayers: parseInt(document.getElementById('numLayers').value),
        dropout: parseFloat(document.getElementById('dropout').value),
        optimizer: document.getElementById('optimizer').value,
        learningRate: parseFloat(document.getElementById('learningRate').value),
        weightDecay: parseFloat(document.getElementById('weightDecay').value),
        maxEpochs: parseInt(document.getElementById('maxEpochs').value),
        patience: parseInt(document.getElementById('patience').value),
      };

      // Load data
      const { numNodes, numFeatures, numClasses } = loadKarateClub();
      const trainRatio = parseFloat(document.getElementById('trainSplit').value);
      createMasks(numNodes, trainRatio);

      // Create model
      model = createModel({ ...config, numFeatures, numClasses });
      optimizer = createOptimizer(model, config);

      log('info', `Model: ${config.numLayers}-layer ${config.layerType.toUpperCase()}, hidden=${config.hiddenChannels}`);
      log('info', `Optimizer: ${config.optimizer}, lr=${config.learningRate}, wd=${config.weightDecay}`);

      let bestLoss = Infinity;
      let patienceCounter = 0;

      for (let epoch = 0; epoch < config.maxEpochs; epoch++) {
        if (stopRequested) {
          log('warning', `Training stopped at epoch ${epoch}`);
          break;
        }

        const startTime = performance.now();

        // Zero gradients
        optimizer.zeroGrad();

        // Forward pass with gradient tracking
        const { graph: output, outputVar } = model.forwardWithGrad(graphData);

        // Compute training loss and accuracy
        const trainIndices = trainMask.map((m, i) => m ? i : -1).filter(i => i >= 0);
        const valIndices = valMask.map((m, i) => m ? i : -1).filter(i => i >= 0);
        const trainLabels = trainIndices.map(i => labels[i]);

        // Gather training logits from the Variable (maintaining graph connection)
        const numClasses = output.x.shape[1];
        const trainLogitsData = new Float32Array(trainIndices.length * numClasses);
        for (let i = 0; i < trainIndices.length; i++) {
          for (let c = 0; c < numClasses; c++) {
            trainLogitsData[i * numClasses + c] = outputVar.data.data[trainIndices[i] * numClasses + c];
          }
        }
        const trainLogitsTensor = new Tensor(trainLogitsData, [trainIndices.length, numClasses]);

        // Create Variable for train logits with proper backward connection
        const trainLogitsVar = new Variable(trainLogitsTensor, {
          requiresGrad: true,
          gradNode: {
            inputs: [outputVar],
            backward: (grad) => {
              // Scatter gradient back to full output
              const fullGrad = new Float32Array(outputVar.data.size);
              for (let i = 0; i < trainIndices.length; i++) {
                for (let c = 0; c < numClasses; c++) {
                  fullGrad[trainIndices[i] * numClasses + c] = grad.data[i * numClasses + c];
                }
              }
              return [new Tensor(fullGrad, outputVar.data.shape)];
            },
            name: 'gather_train'
          },
          name: 'train_logits'
        });

        const loss = crossEntropyLoss(trainLogitsVar, trainLabels);
        const lossVal = loss.data.data[0];

        // Backward pass - now gradients flow through model Variables!
        loss.backward();

        // Update weights
        optimizer.stepOptimizer();

        // Compute metrics
        const trainAcc = computeAccuracy(output.x, labels, trainMask);
        const valLogits = gatherRows(output.x, valIndices);
        const valLabels = valIndices.map(i => labels[i]);
        const valLogitsVar = new Variable(valLogits, { requiresGrad: false });
        const valLoss = crossEntropyLoss(valLogitsVar, valLabels).data.data[0];
        const valAcc = computeAccuracy(output.x, labels, valMask);

        const duration = performance.now() - startTime;

        // Update history
        lossHistory.push(lossVal);
        valLossHistory.push(valLoss);
        accHistory.push(trainAcc);
        valAccHistory.push(valAcc);

        // Store embeddings and predictions for visualization
        currentEmbeddings = output.x;
        currentPredictions = [];
        const numCols = output.x.shape[1];
        for (let i = 0; i < numNodes; i++) {
          let maxVal = -Infinity;
          let maxIdx = 0;
          for (let c = 0; c < numCols; c++) {
            const val = output.x.data[i * numCols + c];
            if (val > maxVal) {
              maxVal = val;
              maxIdx = c;
            }
          }
          currentPredictions.push(maxIdx);
        }

        // Compute t-SNE positions periodically
        if (epoch === 0 || epoch % 10 === 0) {
          computeTSNE(output.x);
        }

        // Update UI
        updateMetrics(epoch, lossVal, trainAcc, valAcc);
        updateProgress(epoch, config.maxEpochs);
        drawCharts();
        drawVisualization();

        if (epoch % 10 === 0) {
          log('info', `Epoch ${epoch}: loss=${lossVal.toFixed(4)}, acc=${(trainAcc*100).toFixed(1)}%, val_acc=${(valAcc*100).toFixed(1)}%`);
        }

        // Early stopping
        if (valLoss < bestLoss - 1e-4) {
          bestLoss = valLoss;
          patienceCounter = 0;
        } else {
          patienceCounter++;
          if (patienceCounter >= config.patience) {
            log('success', `Early stopping at epoch ${epoch} (patience ${config.patience})`);
            showTrainingComplete(epoch + 1, config.maxEpochs, true, false);
            isTraining = false;
            trainBtn.disabled = false;
            stopBtn.disabled = true;
            return;
          }
        }

        // Allow UI to update
        await new Promise(resolve => setTimeout(resolve, 10));
      }

      // Check if stopped by user
      if (stopRequested) {
        showTrainingComplete(lossHistory.length, config.maxEpochs, false, true);
      } else {
        // Normal completion (all epochs)
        showTrainingComplete(config.maxEpochs, config.maxEpochs, false, false);
      }

      log('success', `Training complete! Final val acc: ${(valAccHistory[valAccHistory.length-1]*100).toFixed(1)}%`);

      isTraining = false;
      trainBtn.disabled = false;
      stopBtn.disabled = true;
    }

    function showTrainingComplete(stoppedAt, maxEpochs, earlyStopped, userStopped) {
      const finalAcc = valAccHistory.length > 0 ? (valAccHistory[valAccHistory.length-1]*100).toFixed(1) : '0.0';

      // Update progress bar to 100% and add complete class
      progressFill.style.width = '100%';
      progressFill.classList.remove('complete', 'stopped');
      progressText.classList.remove('complete', 'stopped');

      if (userStopped) {
        progressFill.classList.add('stopped');
        progressText.classList.add('stopped');
        progressText.textContent = `Stopped at epoch ${stoppedAt} | Val Acc: ${finalAcc}%`;
      } else if (earlyStopped) {
        progressFill.classList.add('complete');
        progressText.classList.add('complete');
        progressText.textContent = `Complete (early stopped at ${stoppedAt}) | Val Acc: ${finalAcc}%`;
      } else {
        progressFill.classList.add('complete');
        progressText.classList.add('complete');
        progressText.textContent = `Complete (${maxEpochs} epochs) | Val Acc: ${finalAcc}%`;
      }
    }

    function gatherRows(tensor, indices) {
      const numCols = tensor.shape[1];
      const data = new Float32Array(indices.length * numCols);
      for (let i = 0; i < indices.length; i++) {
        for (let j = 0; j < numCols; j++) {
          data[i * numCols + j] = tensor.data[indices[i] * numCols + j];
        }
      }
      return new Tensor(data, [indices.length, numCols]);
    }

    function computeAccuracy(output, labels, mask) {
      const numClasses = output.shape[1];
      let correct = 0;
      let total = 0;

      for (let i = 0; i < mask.length; i++) {
        if (!mask[i]) continue;

        let maxVal = -Infinity;
        let maxIdx = 0;
        for (let c = 0; c < numClasses; c++) {
          const val = output.data[i * numClasses + c];
          if (val > maxVal) {
            maxVal = val;
            maxIdx = c;
          }
        }

        if (maxIdx === labels[i]) correct++;
        total++;
      }

      return total > 0 ? correct / total : 0;
    }

    function updateMetrics(epoch, loss, trainAcc, valAcc) {
      document.getElementById('currentEpoch').textContent = epoch;
      document.getElementById('currentLoss').textContent = loss.toFixed(3);
      document.getElementById('trainAcc').textContent = `${(trainAcc * 100).toFixed(1)}%`;
      document.getElementById('valAcc').textContent = `${(valAcc * 100).toFixed(1)}%`;
    }

    function updateProgress(epoch, maxEpochs) {
      const percent = ((epoch + 1) / maxEpochs) * 100;
      progressFill.style.width = `${percent}%`;
      progressText.textContent = `Epoch ${epoch + 1} / ${maxEpochs}`;
    }

    function drawCharts() {
      // Loss chart
      drawLineChart(lossCtx, lossCanvas, [
        { data: lossHistory, color: '#3b82f6', label: 'Train' },
        { data: valLossHistory, color: '#f97316', label: 'Val' }
      ], 'Loss');

      // Accuracy chart
      drawLineChart(accCtx, accCanvas, [
        { data: accHistory, color: '#10b981', label: 'Train' },
        { data: valAccHistory, color: '#ec4899', label: 'Val' }
      ], 'Accuracy', true);
    }

    function drawLineChart(ctx, canvas, series, title, isPercentage = false) {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = rect.height;
      const padding = { top: 20, right: 20, bottom: 30, left: 50 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;

      // Clear
      ctx.fillStyle = 'rgba(15, 23, 42, 0.6)';
      ctx.fillRect(0, 0, width, height);

      if (series[0].data.length === 0) return;

      // Find ranges
      let minVal = Infinity, maxVal = -Infinity;
      for (const s of series) {
        for (const v of s.data) {
          minVal = Math.min(minVal, v);
          maxVal = Math.max(maxVal, v);
        }
      }

      if (isPercentage) {
        minVal = 0;
        maxVal = 1;
      }

      const yRange = maxVal - minVal || 1;

      // Draw grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (i / 5) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();

        // Y-axis labels
        const val = maxVal - (i / 5) * yRange;
        ctx.fillStyle = '#9ca3af';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(isPercentage ? `${(val * 100).toFixed(0)}%` : val.toFixed(2), padding.left - 5, y + 4);
      }

      // Draw lines
      for (const s of series) {
        if (s.data.length < 2) continue;

        ctx.beginPath();
        ctx.strokeStyle = s.color;
        ctx.lineWidth = 2;

        for (let i = 0; i < s.data.length; i++) {
          const x = padding.left + (i / (s.data.length - 1)) * chartWidth;
          const y = padding.top + ((maxVal - s.data[i]) / yRange) * chartHeight;

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        ctx.stroke();
      }

      // X-axis label
      ctx.fillStyle = '#9ca3af';
      ctx.textAlign = 'center';
      ctx.fillText('Epoch', width / 2, height - 5);
    }

    // Simple t-SNE implementation for 2D visualization
    function computeTSNE(embeddings) {
      if (!embeddings) return;

      const numNodes = embeddings.shape[0];
      const numDims = embeddings.shape[1];

      // Initialize random positions
      if (tsnePositions.length !== numNodes) {
        tsnePositions = [];
        for (let i = 0; i < numNodes; i++) {
          tsnePositions.push({
            x: Math.random() * 0.8 + 0.1,
            y: Math.random() * 0.8 + 0.1
          });
        }
      }

      // Compute pairwise distances in embedding space
      const distances = [];
      for (let i = 0; i < numNodes; i++) {
        distances[i] = [];
        for (let j = 0; j < numNodes; j++) {
          let sum = 0;
          for (let d = 0; d < numDims; d++) {
            const diff = embeddings.data[i * numDims + d] - embeddings.data[j * numDims + d];
            sum += diff * diff;
          }
          distances[i][j] = Math.sqrt(sum);
        }
      }

      // Simple gradient descent for t-SNE-like layout
      const lr = 0.1;
      for (let iter = 0; iter < 50; iter++) {
        for (let i = 0; i < numNodes; i++) {
          let gradX = 0, gradY = 0;
          for (let j = 0; j < numNodes; j++) {
            if (i === j) continue;

            const dx = tsnePositions[i].x - tsnePositions[j].x;
            const dy = tsnePositions[i].y - tsnePositions[j].y;
            const d2D = Math.sqrt(dx * dx + dy * dy) + 0.001;
            const dHigh = distances[i][j] + 0.001;

            // Attraction/repulsion force
            const force = (d2D - dHigh * 0.05) / d2D;
            gradX += dx * force * 0.01;
            gradY += dy * force * 0.01;
          }

          tsnePositions[i].x -= lr * gradX;
          tsnePositions[i].y -= lr * gradY;

          // Clamp to bounds
          tsnePositions[i].x = Math.max(0.1, Math.min(0.9, tsnePositions[i].x));
          tsnePositions[i].y = Math.max(0.1, Math.min(0.9, tsnePositions[i].y));
        }
      }
    }

    // Main visualization dispatcher
    function drawVisualization() {
      switch (currentView) {
        case 'graph':
          drawGraphStructure();
          break;
        case 'predictions':
          drawPredictions();
          break;
        case 'embeddings':
          drawEmbeddings();
          break;
      }
    }

    // Graph structure view - shows ground truth labels
    function drawGraphStructure() {
      const rect = graphCanvas.getBoundingClientRect();
      graphCanvas.width = rect.width * window.devicePixelRatio;
      graphCanvas.height = rect.height * window.devicePixelRatio;
      graphCtx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = rect.height;
      const padding = 40;

      graphCtx.fillStyle = 'rgba(15, 23, 42, 0.8)';
      graphCtx.fillRect(0, 0, width, height);

      if (!graphData || nodePositions.length === 0) return;

      const numNodes = graphData.numNodes;
      const colors = ['#3b82f6', '#ef4444']; // Blue = Class 0, Red = Class 1

      const scaleX = (x) => padding + x * (width - 2 * padding);
      const scaleY = (y) => padding + y * (height - 2 * padding);

      // Draw edges
      graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      graphCtx.lineWidth = 1;

      const edgeIndex = graphData.edgeIndex;
      const numEdges = graphData.numEdges;
      for (let i = 0; i < numEdges / 2; i++) {
        const src = edgeIndex[i];
        const dst = edgeIndex[numEdges + i];
        graphCtx.beginPath();
        graphCtx.moveTo(scaleX(nodePositions[src].x), scaleY(nodePositions[src].y));
        graphCtx.lineTo(scaleX(nodePositions[dst].x), scaleY(nodePositions[dst].y));
        graphCtx.stroke();
      }

      // Draw nodes (ground truth colors)
      for (let i = 0; i < numNodes; i++) {
        const x = scaleX(nodePositions[i].x);
        const y = scaleY(nodePositions[i].y);
        const color = colors[labels[i]];
        const isTrainNode = trainMask[i];

        graphCtx.beginPath();
        graphCtx.arc(x, y, isTrainNode ? 10 : 8, 0, Math.PI * 2);
        graphCtx.fillStyle = color;
        graphCtx.fill();

        if (!isTrainNode) {
          graphCtx.strokeStyle = 'white';
          graphCtx.lineWidth = 2;
          graphCtx.stroke();
        }

        graphCtx.fillStyle = 'white';
        graphCtx.font = 'bold 9px sans-serif';
        graphCtx.textAlign = 'center';
        graphCtx.textBaseline = 'middle';
        graphCtx.fillText(i.toString(), x, y);
      }

      // Legend
      graphCtx.fillStyle = '#9ca3af';
      graphCtx.font = '11px sans-serif';
      graphCtx.textAlign = 'left';
      graphCtx.fillText('Ground Truth Labels | Blue=Class 0, Red=Class 1 | Filled=Train, Outlined=Val', 10, height - 10);
    }

    // Predictions view - shows predicted labels with correct/incorrect indicators
    function drawPredictions() {
      const rect = graphCanvas.getBoundingClientRect();
      graphCanvas.width = rect.width * window.devicePixelRatio;
      graphCanvas.height = rect.height * window.devicePixelRatio;
      graphCtx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = rect.height;
      const padding = 40;

      graphCtx.fillStyle = 'rgba(15, 23, 42, 0.8)';
      graphCtx.fillRect(0, 0, width, height);

      if (!graphData || nodePositions.length === 0) return;

      const numNodes = graphData.numNodes;
      const scaleX = (x) => padding + x * (width - 2 * padding);
      const scaleY = (y) => padding + y * (height - 2 * padding);

      // Draw edges
      graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      graphCtx.lineWidth = 1;

      const edgeIndex = graphData.edgeIndex;
      const numEdges = graphData.numEdges;
      for (let i = 0; i < numEdges / 2; i++) {
        const src = edgeIndex[i];
        const dst = edgeIndex[numEdges + i];
        graphCtx.beginPath();
        graphCtx.moveTo(scaleX(nodePositions[src].x), scaleY(nodePositions[src].y));
        graphCtx.lineTo(scaleX(nodePositions[dst].x), scaleY(nodePositions[dst].y));
        graphCtx.stroke();
      }

      // Draw nodes with prediction status
      for (let i = 0; i < numNodes; i++) {
        const x = scaleX(nodePositions[i].x);
        const y = scaleY(nodePositions[i].y);
        const prediction = currentPredictions[i] ?? labels[i];
        const isCorrect = prediction === labels[i];

        // Green = correct, Red = incorrect
        const color = isCorrect ? '#10b981' : '#ef4444';

        graphCtx.beginPath();
        graphCtx.arc(x, y, 10, 0, Math.PI * 2);
        graphCtx.fillStyle = color;
        graphCtx.fill();

        // Add checkmark or X symbol
        graphCtx.fillStyle = 'white';
        graphCtx.font = 'bold 10px sans-serif';
        graphCtx.textAlign = 'center';
        graphCtx.textBaseline = 'middle';
        graphCtx.fillText(isCorrect ? '‚úì' : '‚úó', x, y);
      }

      // Count correct predictions
      const correct = currentPredictions.reduce((sum, pred, i) => sum + (pred === labels[i] ? 1 : 0), 0);
      const accuracy = currentPredictions.length > 0 ? (correct / numNodes * 100).toFixed(1) : 0;

      graphCtx.fillStyle = '#9ca3af';
      graphCtx.font = '11px sans-serif';
      graphCtx.textAlign = 'left';
      graphCtx.fillText(`Predictions | Green=Correct, Red=Incorrect | Accuracy: ${accuracy}% (${correct}/${numNodes})`, 10, height - 10);
    }

    // Embeddings view - t-SNE visualization of learned embeddings
    function drawEmbeddings() {
      const rect = graphCanvas.getBoundingClientRect();
      graphCanvas.width = rect.width * window.devicePixelRatio;
      graphCanvas.height = rect.height * window.devicePixelRatio;
      graphCtx.scale(window.devicePixelRatio, window.devicePixelRatio);

      const width = rect.width;
      const height = rect.height;
      const padding = 40;

      graphCtx.fillStyle = 'rgba(15, 23, 42, 0.8)';
      graphCtx.fillRect(0, 0, width, height);

      if (!graphData || tsnePositions.length === 0) {
        // Show message if no embeddings yet
        graphCtx.fillStyle = '#9ca3af';
        graphCtx.font = '14px sans-serif';
        graphCtx.textAlign = 'center';
        graphCtx.fillText('Start training to see embedding visualization', width / 2, height / 2);
        return;
      }

      const numNodes = graphData.numNodes;
      const colors = ['#3b82f6', '#ef4444'];

      const scaleX = (x) => padding + x * (width - 2 * padding);
      const scaleY = (y) => padding + y * (height - 2 * padding);

      // Draw connections between same-class nodes (lighter)
      graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      graphCtx.lineWidth = 1;
      for (let i = 0; i < numNodes; i++) {
        for (let j = i + 1; j < numNodes; j++) {
          if (labels[i] === labels[j]) {
            graphCtx.beginPath();
            graphCtx.moveTo(scaleX(tsnePositions[i].x), scaleY(tsnePositions[i].y));
            graphCtx.lineTo(scaleX(tsnePositions[j].x), scaleY(tsnePositions[j].y));
            graphCtx.stroke();
          }
        }
      }

      // Draw nodes using t-SNE positions
      for (let i = 0; i < numNodes; i++) {
        const x = scaleX(tsnePositions[i].x);
        const y = scaleY(tsnePositions[i].y);
        const color = colors[labels[i]];

        graphCtx.beginPath();
        graphCtx.arc(x, y, 8, 0, Math.PI * 2);
        graphCtx.fillStyle = color;
        graphCtx.fill();

        graphCtx.fillStyle = 'white';
        graphCtx.font = 'bold 8px sans-serif';
        graphCtx.textAlign = 'center';
        graphCtx.textBaseline = 'middle';
        graphCtx.fillText(i.toString(), x, y);
      }

      graphCtx.fillStyle = '#9ca3af';
      graphCtx.font = '11px sans-serif';
      graphCtx.textAlign = 'left';
      graphCtx.fillText('t-SNE Embedding | Nodes colored by ground truth | Similar embeddings cluster together', 10, height - 10);
    }

    // Get node at position (for hover)
    function getNodeAtPosition(mouseX, mouseY) {
      const rect = graphCanvas.getBoundingClientRect();
      const x = mouseX - rect.left;
      const y = mouseY - rect.top;

      const width = rect.width;
      const height = rect.height;
      const padding = 40;

      const positions = currentView === 'embeddings' ? tsnePositions : nodePositions;
      if (positions.length === 0) return null;

      const scaleX = (px) => padding + px * (width - 2 * padding);
      const scaleY = (py) => padding + py * (height - 2 * padding);

      for (let i = 0; i < positions.length; i++) {
        const nx = scaleX(positions[i].x);
        const ny = scaleY(positions[i].y);
        const dist = Math.sqrt((x - nx) ** 2 + (y - ny) ** 2);
        if (dist < 15) {
          return i;
        }
      }
      return null;
    }

    // Show tooltip for node
    function showNodeTooltip(nodeIdx, mouseX, mouseY) {
      const prediction = currentPredictions[nodeIdx] ?? null;
      const trueLabel = labels[nodeIdx];
      const isCorrect = prediction === trueLabel;
      const isTrainNode = trainMask[nodeIdx];

      let html = `<div class="tooltip-title">Node ${nodeIdx}</div>`;
      html += `<div class="tooltip-row"><span class="tooltip-label">True Label:</span><span class="tooltip-value">${trueLabel === 0 ? 'Class 0 (Mr. Hi)' : 'Class 1 (Officer)'}</span></div>`;
      html += `<div class="tooltip-row"><span class="tooltip-label">Split:</span><span class="tooltip-value">${isTrainNode ? 'Training' : 'Validation'}</span></div>`;

      if (prediction !== null) {
        html += `<div class="tooltip-row"><span class="tooltip-label">Prediction:</span><span class="tooltip-value ${isCorrect ? 'tooltip-correct' : 'tooltip-incorrect'}">${prediction === 0 ? 'Class 0' : 'Class 1'} ${isCorrect ? '‚úì' : '‚úó'}</span></div>`;
      }

      // Get node degree
      const edgeIndex = graphData.edgeIndex;
      const numEdges = graphData.numEdges;
      let degree = 0;
      for (let i = 0; i < numEdges; i++) {
        if (edgeIndex[i] === nodeIdx) degree++;
      }
      html += `<div class="tooltip-row"><span class="tooltip-label">Degree:</span><span class="tooltip-value">${degree}</span></div>`;

      // Show embedding values if available
      if (currentEmbeddings && currentView !== 'graph') {
        const numCols = currentEmbeddings.shape[1];
        const logits = [];
        for (let c = 0; c < numCols; c++) {
          logits.push(currentEmbeddings.data[nodeIdx * numCols + c].toFixed(3));
        }
        html += `<div class="tooltip-row"><span class="tooltip-label">Logits:</span><span class="tooltip-value">[${logits.join(', ')}]</span></div>`;
      }

      tooltip.innerHTML = html;
      tooltip.style.display = 'block';

      // Position tooltip
      const rect = graphCanvas.parentElement.getBoundingClientRect();
      let left = mouseX - rect.left + 15;
      let top = mouseY - rect.top + 15;

      // Keep within bounds
      if (left + 200 > rect.width) left = mouseX - rect.left - 200;
      if (top + 150 > rect.height) top = mouseY - rect.top - 150;

      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
    }

    function hideTooltip() {
      tooltip.style.display = 'none';
    }

    // Legacy function for backwards compatibility
    function drawGraph(embeddings) {
      if (embeddings) {
        currentEmbeddings = embeddings;
        const numNodes = embeddings.shape[0];
        const numCols = embeddings.shape[1];
        currentPredictions = [];
        for (let i = 0; i < numNodes; i++) {
          let maxVal = -Infinity;
          let maxIdx = 0;
          for (let c = 0; c < numCols; c++) {
            const val = embeddings.data[i * numCols + c];
            if (val > maxVal) {
              maxVal = val;
              maxIdx = c;
            }
          }
          currentPredictions.push(maxIdx);
        }
      }
      drawVisualization();
    }

    function log(type, message) {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const time = new Date().toLocaleTimeString();
      entry.textContent = `[${time}] ${message}`;
      logPanel.appendChild(entry);
      logPanel.scrollTop = logPanel.scrollHeight;
    }

    // Event listeners
    trainBtn.addEventListener('click', train);
    stopBtn.addEventListener('click', () => {
      stopRequested = true;
    });
    resetBtn.addEventListener('click', () => {
      lossHistory = [];
      valLossHistory = [];
      accHistory = [];
      valAccHistory = [];
      currentEmbeddings = null;
      currentPredictions = [];
      tsnePositions = [];
      updateMetrics(0, 0, 0, 0);
      progressFill.style.width = '0%';
      progressFill.classList.remove('complete', 'stopped');
      progressText.classList.remove('complete', 'stopped');
      progressText.textContent = 'Ready to train';
      drawCharts();
      drawVisualization();
      log('info', 'Model reset');
    });

    // Dataset selection
    const csvUploadArea = document.getElementById('csvUploadArea');
    const csvFileInput = document.getElementById('csvFileInput');
    const loadedDatasetInfo = document.getElementById('loadedDatasetInfo');

    document.querySelectorAll('.dataset-card').forEach(card => {
      card.addEventListener('click', () => {
        document.querySelectorAll('.dataset-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        currentDataset = card.dataset.dataset;
        // Reset predictions on dataset change
        currentEmbeddings = null;
        currentPredictions = [];
        tsnePositions = [];

        // Show/hide CSV upload area
        if (currentDataset === 'custom') {
          csvUploadArea.classList.add('visible');
        } else {
          csvUploadArea.classList.remove('visible');
          loadedDatasetInfo.classList.remove('visible');
        }

        if (currentDataset === 'karate') {
          loadKarateClub();
          drawVisualization();
        }
      });
    });

    // CSV upload area click handler
    csvUploadArea.addEventListener('click', () => {
      csvFileInput.click();
    });

    // Drag and drop handlers
    csvUploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      csvUploadArea.classList.add('dragover');
    });

    csvUploadArea.addEventListener('dragleave', () => {
      csvUploadArea.classList.remove('dragover');
    });

    csvUploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      csvUploadArea.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.csv'));
      if (files.length > 0) {
        handleCSVFiles(files);
      }
    });

    // File input change handler
    csvFileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      if (files.length > 0) {
        handleCSVFiles(files);
      }
    });

    // Train split slider
    const trainSplit = document.getElementById('trainSplit');
    trainSplit.addEventListener('input', () => {
      const val = parseFloat(trainSplit.value);
      document.getElementById('splitText').textContent = `${Math.round(val * 100)}% train / ${Math.round((1-val) * 100)}% val`;
    });

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentView = tab.dataset.view;
        drawVisualization();
      });
    });

    // Hover events for tooltips
    graphCanvas.addEventListener('mousemove', (e) => {
      const nodeIdx = getNodeAtPosition(e.clientX, e.clientY);
      if (nodeIdx !== null) {
        showNodeTooltip(nodeIdx, e.clientX, e.clientY);
        graphCanvas.style.cursor = 'pointer';
      } else {
        hideTooltip();
        graphCanvas.style.cursor = 'crosshair';
      }
    });

    graphCanvas.addEventListener('mouseleave', () => {
      hideTooltip();
    });

    // Initial load
    loadKarateClub();
    drawVisualization();
    drawCharts();
  </script>
</body>
</html>
