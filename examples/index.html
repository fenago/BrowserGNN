<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BrowserGNN by Dr. Lee - Interactive Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      min-height: 100vh;
      line-height: 1.6;
    }

    h1 {
      text-align: center;
      color: #00d9ff;
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 1rem;
    }

    .hero-badge {
      text-align: center;
      margin-bottom: 2rem;
    }

    .hero-badge span {
      background: linear-gradient(135deg, #ff6b6b 0%, #feca57 100%);
      color: #1a1a2e;
      padding: 8px 20px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .card h2 {
      color: #00d9ff;
      margin-top: 0;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .card h2::before {
      content: '';
      width: 8px;
      height: 8px;
      background: #00d9ff;
      border-radius: 50%;
    }

    .intro-text {
      color: #ccc;
      font-size: 1rem;
      margin-bottom: 15px;
    }

    .intro-text strong {
      color: #00d9ff;
    }

    .status {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    .status-item {
      background: rgba(0, 217, 255, 0.1);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.9rem;
    }

    .status-item strong {
      color: #00d9ff;
    }

    .demo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .demo-button {
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: left;
    }

    .demo-button:hover {
      border-color: #00d9ff;
      background: rgba(0, 217, 255, 0.1);
      transform: translateY(-2px);
    }

    .demo-button.active {
      border-color: #00d9ff;
      background: rgba(0, 217, 255, 0.15);
    }

    .demo-button h3 {
      color: #00d9ff;
      margin: 0 0 8px 0;
      font-size: 1.1rem;
    }

    .demo-button p {
      color: #999;
      margin: 0;
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .demo-button .badge {
      display: inline-block;
      background: rgba(0, 217, 255, 0.2);
      color: #00d9ff;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      margin-top: 10px;
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 20px;
    }

    @media (max-width: 900px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }

    .output {
      background: #0d1117;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.85rem;
      line-height: 1.5;
      max-height: 500px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    .output .info { color: #58a6ff; }
    .output .success { color: #3fb950; }
    .output .warning { color: #d29922; }
    .output .error { color: #f85149; }
    .output .time { color: #8b949e; }
    .output .header { color: #ff7b72; font-weight: bold; }
    .output .data { color: #a5d6ff; }

    .graph-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .graph-viz {
      display: flex;
      justify-content: center;
    }

    .graph-viz canvas {
      background: #0d1117;
      border-radius: 8px;
    }

    .explanation-box {
      background: rgba(0, 0, 0, 0.4);
      border-left: 4px solid #00d9ff;
      padding: 15px;
      border-radius: 0 8px 8px 0;
      font-size: 0.9rem;
    }

    .explanation-box h4 {
      color: #00d9ff;
      margin: 0 0 10px 0;
      font-size: 1rem;
    }

    .explanation-box p {
      color: #bbb;
      margin: 0 0 10px 0;
    }

    .explanation-box ul {
      margin: 0;
      padding-left: 20px;
      color: #999;
    }

    .explanation-box li {
      margin-bottom: 5px;
    }

    .explanation-box code {
      background: rgba(0, 217, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      color: #00d9ff;
      font-size: 0.85rem;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 0.85rem;
    }

    .data-table th {
      background: rgba(0, 217, 255, 0.1);
      color: #00d9ff;
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .data-table td {
      padding: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      color: #ccc;
    }

    .model-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }

    .layer-card {
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 15px;
      border-radius: 6px;
      border-left: 3px solid #00d9ff;
    }

    .layer-card .name {
      font-weight: 600;
      color: #00d9ff;
      font-size: 0.9rem;
    }

    .layer-card .params {
      font-size: 0.8rem;
      color: #888;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: #666;
    }

    footer a {
      color: #00d9ff;
      text-decoration: none;
    }

    .legend {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
      font-size: 0.85rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #888;
    }

    .legend-item .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .node-features {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin-top: 10px;
    }

    .node-features h5 {
      color: #00d9ff;
      margin: 0 0 8px 0;
      font-size: 0.9rem;
    }

    .feature-row {
      display: flex;
      gap: 10px;
      margin-bottom: 4px;
      font-family: monospace;
      font-size: 0.8rem;
    }

    .feature-row .node-id {
      color: #00d9ff;
      width: 60px;
    }

    .feature-row .values {
      color: #888;
    }
  </style>
</head>
<body>
  <h1>BrowserGNN</h1>
  <p class="subtitle">by Dr. Lee | Graph Neural Networks Running 100% in Your Browser</p>
  <div class="hero-badge">
    <span>World's First Browser-Native GNN Library</span>
  </div>

  <!-- What is this? -->
  <div class="card">
    <h2>What is This Demo?</h2>
    <p class="intro-text">
      This demo runs <strong>Graph Neural Networks (GNNs)</strong> entirely in your browser - no server required!
      GNNs are a type of neural network designed to work with graph-structured data (nodes connected by edges),
      like social networks, molecules, or knowledge graphs.
    </p>
    <p class="intro-text">
      <strong>What you'll see:</strong> We create a small graph with 5 nodes and run different GNN architectures
      to predict which "class" each node belongs to. This is called <strong>node classification</strong> -
      a fundamental task in graph machine learning.
    </p>
  </div>

  <!-- Backend Status -->
  <div class="card">
    <h2>Backend Status</h2>
    <div class="status" id="backend-status">
      <div class="status-item"><strong>Status:</strong> <span id="status">Initializing...</span></div>
      <div class="status-item"><strong>Backend:</strong> <span id="backend">-</span></div>
      <div class="status-item"><strong>WebGPU:</strong> <span id="webgpu">-</span></div>
      <div class="status-item"><strong>WASM:</strong> <span id="wasm">-</span></div>
    </div>
  </div>

  <!-- Demo Selection -->
  <div class="card">
    <h2>Choose a Demo</h2>
    <p class="intro-text">Click on a GNN architecture to learn how it works and see it in action:</p>

    <div class="demo-grid">
      <div class="demo-button" onclick="runGCNDemo()" id="btn-gcn">
        <h3>GCN - Graph Convolutional Network</h3>
        <p>The classic GNN. Each node aggregates features from its neighbors, weighted by node degree. Simple but powerful.</p>
        <span class="badge">Kipf & Welling 2017</span>
      </div>

      <div class="demo-button" onclick="runGATDemo()" id="btn-gat">
        <h3>GAT - Graph Attention Network</h3>
        <p>Uses attention to learn which neighbors are most important. Different heads capture different relationship types.</p>
        <span class="badge">Velickovic et al. 2018</span>
      </div>

      <div class="demo-button" onclick="runSAGEDemo()" id="btn-sage">
        <h3>GraphSAGE</h3>
        <p>Samples and aggregates neighbor features. Great for large graphs and can generalize to unseen nodes.</p>
        <span class="badge">Hamilton et al. 2017</span>
      </div>

      <div class="demo-button" onclick="runBenchmark()" id="btn-bench">
        <h3>Performance Benchmark</h3>
        <p>Test inference speed on graphs of different sizes (10 to 500 nodes). See how BrowserGNN scales.</p>
        <span class="badge">Speed Test</span>
      </div>
    </div>
  </div>

  <!-- Real Data Demos -->
  <div class="card" style="border: 2px solid #feca57; background: rgba(254, 202, 87, 0.05);">
    <h2 style="color: #feca57;">Real-World Data Demos</h2>
    <p class="intro-text">
      <strong style="color: #feca57;">NEW!</strong> These demos use <strong>real datasets</strong> with actual names and ground-truth labels,
      not synthetic test data. See GNNs solving actual problems!
    </p>

    <div class="demo-grid">
      <div class="demo-button" onclick="runKarateClubGCN()" id="btn-karate-gcn" style="border-color: rgba(254, 202, 87, 0.3);">
        <h3 style="color: #feca57;">Karate Club (GCN)</h3>
        <p>Zachary's famous 1977 study: 34 karate club members split into 2 factions. Can GCN predict who went where?</p>
        <span class="badge" style="background: rgba(254, 202, 87, 0.2); color: #feca57;">Real Social Network</span>
      </div>

      <div class="demo-button" onclick="runKarateClubGAT()" id="btn-karate-gat" style="border-color: rgba(254, 202, 87, 0.3);">
        <h3 style="color: #feca57;">Karate Club (GAT)</h3>
        <p>Same dataset with Graph Attention - which friendships matter most for predicting loyalty?</p>
        <span class="badge" style="background: rgba(254, 202, 87, 0.2); color: #feca57;">Attention Analysis</span>
      </div>

      <div class="demo-button" onclick="runKarateClubSAGE()" id="btn-karate-sage" style="border-color: rgba(254, 202, 87, 0.3);">
        <h3 style="color: #feca57;">Karate Club (GraphSAGE)</h3>
        <p>GraphSAGE on the karate club - sample-and-aggregate approach to community detection.</p>
        <span class="badge" style="background: rgba(254, 202, 87, 0.2); color: #feca57;">Sampling-Based</span>
      </div>

      <div class="demo-button" onclick="runMoleculeDemo()" id="btn-molecule" style="border-color: rgba(254, 202, 87, 0.3);">
        <h3 style="color: #feca57;">Molecule: Caffeine</h3>
        <p>Predict atom properties in a caffeine molecule. Atoms as nodes, bonds as edges!</p>
        <span class="badge" style="background: rgba(254, 202, 87, 0.2); color: #feca57;">Chemistry</span>
      </div>
    </div>
  </div>

  <!-- Main Content Area -->
  <div class="main-content">
    <!-- Left: Output and Model -->
    <div>
      <div class="card">
        <h2>Output Console</h2>
        <div class="output" id="output">
<span class="header">Welcome to BrowserGNN!</span>

Click one of the demo buttons above to run a Graph Neural Network.

<span class="info">What will happen:</span>
1. We create a graph with 5 nodes and 10 edges
2. Each node has 3 initial features (random values)
3. The GNN processes the graph through multiple layers
4. Output: probability of each node belonging to Class 0 or Class 1

<span class="data">This is node classification - predicting labels for nodes
based on their features AND their connections to other nodes.</span>
        </div>
      </div>

      <div class="card">
        <h2>Model Architecture</h2>
        <p class="intro-text" id="model-description">Select a demo to see the neural network layers used.</p>
        <div class="model-summary" id="model-summary">
          <div class="layer-card">
            <div class="name">Waiting...</div>
            <div class="params">Run a demo to see model details</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Right: Graph Visualization and Explanation -->
    <div class="graph-section">
      <div class="card">
        <h2>Input Graph</h2>
        <div class="graph-viz">
          <canvas id="graph-canvas" width="360" height="280"></canvas>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="dot" style="background: #00d9ff;"></div>
            <span>Node (with ID)</span>
          </div>
          <div class="legend-item">
            <div class="dot" style="background: transparent; border: 2px solid #00d9ff;"></div>
            <span>Edge (connection)</span>
          </div>
        </div>

        <div class="node-features" id="node-features">
          <h5>Node Input Features (3 values per node)</h5>
          <div class="feature-row"><span class="node-id">Node 0:</span><span class="values">[1.0, 0.5, 0.2]</span></div>
          <div class="feature-row"><span class="node-id">Node 1:</span><span class="values">[0.8, 0.3, 0.9]</span></div>
          <div class="feature-row"><span class="node-id">Node 2:</span><span class="values">[0.2, 0.7, 0.4]</span></div>
          <div class="feature-row"><span class="node-id">Node 3:</span><span class="values">[0.5, 0.1, 0.8]</span></div>
          <div class="feature-row"><span class="node-id">Node 4:</span><span class="values">[0.9, 0.6, 0.3]</span></div>
        </div>
      </div>

      <div class="card">
        <h2>How to Interpret Results</h2>
        <div class="explanation-box" id="interpretation">
          <h4>Understanding the Output</h4>
          <p>After running a demo, you'll see predictions like:</p>
          <p><code>Node 0: Class 0: 0.62, Class 1: 0.38</code></p>
          <p>This means:</p>
          <ul>
            <li><strong>62% probability</strong> Node 0 belongs to Class 0</li>
            <li><strong>38% probability</strong> Node 0 belongs to Class 1</li>
            <li>The model would predict <strong>Class 0</strong> for this node</li>
          </ul>
          <p style="margin-top: 15px; color: #00d9ff;">
            <strong>Key insight:</strong> Connected nodes tend to get similar predictions!
            This is because GNNs aggregate information from neighbors.
          </p>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <p>BrowserGNN by Dr. Lee | <a href="https://github.com/fenago/BrowserGNN" target="_blank">GitHub</a> | MIT License</p>
    <p style="color: #444; font-size: 0.85rem;">The world's first comprehensive Graph Neural Network library for the browser</p>
  </footer>

  <script type="module">
    import {
      GraphData,
      GCNConv,
      GATConv,
      SAGEConv,
      Sequential,
      ReLU,
      Softmax,
      Dropout,
      createBrowserGNN,
      randomGraph,
    } from '../src/index.ts';

    let initialized = false;
    let currentGraph = null;

    function log(message, type = '') {
      const output = document.getElementById('output');
      const span = document.createElement('span');
      span.className = type;
      span.textContent = message + '\n';
      output.appendChild(span);
      output.scrollTop = output.scrollHeight;
    }

    function clearOutput() {
      document.getElementById('output').innerHTML = '';
    }

    function setActiveButton(id) {
      document.querySelectorAll('.demo-button').forEach(btn => btn.classList.remove('active'));
      if (id) document.getElementById(id).classList.add('active');
    }

    async function init() {
      try {
        const { backend, info } = await createBrowserGNN();

        document.getElementById('status').textContent = 'Ready';
        document.getElementById('status').style.color = '#3fb950';
        document.getElementById('backend').textContent = backend;
        document.getElementById('webgpu').textContent = backend === 'webgpu' ? 'Active' : 'Not used';
        document.getElementById('wasm').textContent = backend === 'wasm' ? 'Active' : 'Not used';

        initialized = true;

        // Draw initial graph
        visualizeGraph(createTestGraph());
      } catch (err) {
        document.getElementById('status').textContent = 'Error';
        document.getElementById('status').style.color = '#f85149';
      }
    }

    function createTestGraph() {
      return new GraphData({
        x: new Float32Array([
          1.0, 0.5, 0.2,
          0.8, 0.3, 0.9,
          0.2, 0.7, 0.4,
          0.5, 0.1, 0.8,
          0.9, 0.6, 0.3,
        ]),
        numNodes: 5,
        numFeatures: 3,
        edgeIndex: new Uint32Array([
          0, 0, 1, 1, 2, 2, 3, 3, 4, 4,
          1, 2, 0, 2, 1, 3, 2, 4, 0, 3,
        ]),
        numEdges: 10,
      });
    }

    function visualizeGraph(graph, predictions = null) {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 100;

      const nodePositions = [];
      for (let i = 0; i < graph.numNodes; i++) {
        const angle = (2 * Math.PI * i) / graph.numNodes - Math.PI / 2;
        nodePositions.push({
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle),
        });
      }

      // Draw edges
      ctx.strokeStyle = '#00d9ff';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.3;

      for (let i = 0; i < graph.numEdges; i++) {
        const src = graph.edgeIndex[i];
        const dst = graph.edgeIndex[graph.numEdges + i];

        ctx.beginPath();
        ctx.moveTo(nodePositions[src].x, nodePositions[src].y);
        ctx.lineTo(nodePositions[dst].x, nodePositions[dst].y);
        ctx.stroke();
      }

      // Draw nodes
      ctx.globalAlpha = 1;
      for (let i = 0; i < graph.numNodes; i++) {
        const pos = nodePositions[i];

        // Color based on prediction if available
        let color = '#00d9ff';
        if (predictions && predictions[i]) {
          const p0 = predictions[i][0];
          const p1 = predictions[i][1];
          // Blend between blue (class 0) and orange (class 1)
          const r = Math.round(0 + (255 - 0) * p1);
          const g = Math.round(217 + (165 - 217) * p1);
          const b = Math.round(255 + (0 - 255) * p1);
          color = `rgb(${r}, ${g}, ${b})`;
        }

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 25, 0, 2 * Math.PI);
        ctx.fill();

        ctx.fillStyle = '#1a1a2e';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i.toString(), pos.x, pos.y);
      }

      currentGraph = graph;
    }

    function updateModelSummary(description, layers) {
      document.getElementById('model-description').innerHTML = description;
      const container = document.getElementById('model-summary');
      container.innerHTML = layers.map((layer, i) => `
        <div class="layer-card">
          <div class="name">${layer.name}</div>
          <div class="params">${layer.desc}</div>
        </div>
      `).join('');
    }

    function updateInterpretation(html) {
      document.getElementById('interpretation').innerHTML = html;
    }

    window.runGCNDemo = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-gcn');
      clearOutput();

      log('='.repeat(50), 'header');
      log('GCN - GRAPH CONVOLUTIONAL NETWORK DEMO', 'header');
      log('='.repeat(50), 'header');
      log('');
      log('WHAT IS GCN?', 'info');
      log('GCN uses spectral graph convolutions to aggregate neighbor');
      log('features. Each node\'s new representation is computed as a');
      log('weighted sum of its neighbors\' features.', '');
      log('');
      log('FORMULA: h_i\' = ReLU( SUM_j (1/sqrt(d_i*d_j)) * W * h_j )', 'data');
      log('  - d_i, d_j = degrees of nodes i and j', '');
      log('  - W = learnable weight matrix', '');
      log('  - Normalizing by degree prevents high-degree nodes from dominating', '');
      log('');

      const graph = createTestGraph();

      log('INPUT GRAPH:', 'info');
      log(`  Nodes: ${graph.numNodes}`, '');
      log(`  Edges: ${graph.numEdges}`, '');
      log(`  Features per node: ${graph.numFeatures}`, '');
      log('');

      const model = new Sequential([
        new GCNConv({ inChannels: 3, outChannels: 16 }),
        new ReLU(),
        new GCNConv({ inChannels: 16, outChannels: 8 }),
        new ReLU(),
        new GCNConv({ inChannels: 8, outChannels: 2 }),
        new Softmax(),
      ]);

      model.eval();

      updateModelSummary(
        'A 3-layer GCN that transforms 3 input features to 2 output classes. Each GCN layer aggregates neighbor features weighted by degree normalization.',
        [
          { name: 'GCNConv(3→16)', desc: 'Aggregate neighbors, expand to 16 dims' },
          { name: 'ReLU', desc: 'Non-linear activation' },
          { name: 'GCNConv(16→8)', desc: 'Further aggregation, reduce to 8 dims' },
          { name: 'ReLU', desc: 'Non-linear activation' },
          { name: 'GCNConv(8→2)', desc: 'Final layer, output 2 class scores' },
          { name: 'Softmax', desc: 'Convert to probabilities (sum to 1)' },
        ]
      );

      log('MODEL ARCHITECTURE:', 'info');
      log('  Input (3 features) → GCN → ReLU → GCN → ReLU → GCN → Softmax → Output (2 classes)', '');
      log('');
      log('RUNNING INFERENCE...', 'info');

      const start = performance.now();
      const output = await model.forward(graph);
      const elapsed = performance.now() - start;

      log(`Done in ${elapsed.toFixed(2)}ms`, 'time');
      log('');
      log('PREDICTIONS (Node Classification):', 'success');
      log('─'.repeat(45), '');

      const predictions = [];
      for (let i = 0; i < output.numNodes; i++) {
        const p0 = output.x.get(i, 0);
        const p1 = output.x.get(i, 1);
        predictions.push([p0, p1]);
        const predicted = p0 > p1 ? 'Class 0' : 'Class 1';
        const confidence = Math.max(p0, p1) * 100;
        log(`  Node ${i}: Class 0: ${p0.toFixed(3)}, Class 1: ${p1.toFixed(3)}  →  ${predicted} (${confidence.toFixed(1)}% confident)`, '');
      }

      visualizeGraph(graph, predictions);

      log('');
      log('INTERPRETATION:', 'info');
      log('Notice how connected nodes often have similar predictions!', '');
      log('This is because GCN aggregates information from neighbors.', '');

      updateInterpretation(`
        <h4>GCN Results Explained</h4>
        <p>The GCN processed your graph through <strong>3 message-passing layers</strong>.</p>
        <p>At each layer, every node:</p>
        <ul>
          <li>Collected features from its neighbors</li>
          <li>Weighted them by <code>1/sqrt(degree_i * degree_j)</code></li>
          <li>Combined them with learnable weights</li>
        </ul>
        <p style="margin-top: 15px; color: #00d9ff;">
          <strong>The graph is now colored by prediction!</strong><br>
          Blue = Class 0, Orange = Class 1
        </p>
      `);
    };

    window.runGATDemo = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-gat');
      clearOutput();

      log('='.repeat(50), 'header');
      log('GAT - GRAPH ATTENTION NETWORK DEMO', 'header');
      log('='.repeat(50), 'header');
      log('');
      log('WHAT IS GAT?', 'info');
      log('GAT learns to weight neighbors differently using attention.');
      log('Not all neighbors are equally important! GAT learns which');
      log('connections matter most for the prediction task.', '');
      log('');
      log('KEY INNOVATION: Multi-head attention', 'data');
      log('  - Multiple attention "heads" run in parallel', '');
      log('  - Each head can learn different patterns', '');
      log('  - Results are concatenated or averaged', '');
      log('');
      log('FORMULA: alpha_ij = softmax( LeakyReLU(a^T [Wh_i || Wh_j]) )', 'data');
      log('  - alpha_ij = learned attention weight for edge i→j', '');
      log('  - || means concatenation', '');
      log('');

      const graph = createTestGraph();

      log('INPUT GRAPH:', 'info');
      log(`  Nodes: ${graph.numNodes}`, '');
      log(`  Edges: ${graph.numEdges}`, '');
      log(`  Features per node: ${graph.numFeatures}`, '');
      log('');

      const model = new Sequential([
        new GATConv({ inChannels: 3, outChannels: 8, heads: 2 }),
        new ReLU(),
        new GATConv({ inChannels: 16, outChannels: 2, heads: 1, concat: false }),
        new Softmax(),
      ]);

      model.eval();

      updateModelSummary(
        'A 2-layer GAT with multi-head attention. The first layer uses 2 attention heads to learn different relationship patterns.',
        [
          { name: 'GATConv(3→8, 2 heads)', desc: '2 attention heads, output: 8*2=16 dims' },
          { name: 'ReLU', desc: 'Non-linear activation' },
          { name: 'GATConv(16→2, 1 head)', desc: 'Single head, average output: 2 dims' },
          { name: 'Softmax', desc: 'Convert to probabilities' },
        ]
      );

      log('MODEL ARCHITECTURE:', 'info');
      log('  Input → GAT(2 heads) → ReLU → GAT(1 head) → Softmax → Output', '');
      log('');
      log('RUNNING INFERENCE WITH ATTENTION...', 'info');

      const start = performance.now();
      const output = await model.forward(graph);
      const elapsed = performance.now() - start;

      log(`Done in ${elapsed.toFixed(2)}ms`, 'time');
      log('');
      log('ATTENTION-WEIGHTED PREDICTIONS:', 'success');
      log('─'.repeat(45), '');

      const predictions = [];
      for (let i = 0; i < output.numNodes; i++) {
        const p0 = output.x.get(i, 0);
        const p1 = output.x.get(i, 1);
        predictions.push([p0, p1]);
        const predicted = p0 > p1 ? 'Class 0' : 'Class 1';
        const confidence = Math.max(p0, p1) * 100;
        log(`  Node ${i}: Class 0: ${p0.toFixed(3)}, Class 1: ${p1.toFixed(3)}  →  ${predicted} (${confidence.toFixed(1)}% confident)`, '');
      }

      visualizeGraph(graph, predictions);

      log('');
      log('WHY USE ATTENTION?', 'info');
      log('In citation networks, not all references are equally important.', '');
      log('In social networks, some friends influence you more than others.', '');
      log('GAT learns these importance weights automatically!', '');

      updateInterpretation(`
        <h4>GAT Results Explained</h4>
        <p>GAT computed <strong>attention weights</strong> for each edge, learning which neighbors matter most.</p>
        <p>The 2 attention heads learned:</p>
        <ul>
          <li>Head 1: One pattern of neighbor importance</li>
          <li>Head 2: A different pattern</li>
          <li>These are concatenated for a richer representation</li>
        </ul>
        <p style="margin-top: 15px; color: #00d9ff;">
          <strong>Different predictions than GCN!</strong><br>
          Attention lets the model focus on relevant neighbors.
        </p>
      `);
    };

    window.runSAGEDemo = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-sage');
      clearOutput();

      log('='.repeat(50), 'header');
      log('GraphSAGE DEMO', 'header');
      log('='.repeat(50), 'header');
      log('');
      log('WHAT IS GraphSAGE?', 'info');
      log('GraphSAGE (SAmple and aggreGatE) was designed for HUGE graphs');
      log('where you can\'t process all neighbors. It samples a fixed', '');
      log('number of neighbors and aggregates their features.', '');
      log('');
      log('KEY INNOVATION: Inductive learning', 'data');
      log('  - Can generalize to unseen nodes!', '');
      log('  - Train on one part of graph, predict on another', '');
      log('  - Great for dynamic graphs with new nodes', '');
      log('');
      log('AGGREGATORS:', 'data');
      log('  - MEAN: Average neighbor features', '');
      log('  - MAX: Take element-wise max (like max pooling in CNNs)', '');
      log('  - SUM: Sum all neighbor features', '');
      log('  - POOL: Apply MLP then max-pool', '');
      log('');

      const graph = createTestGraph();

      log('INPUT GRAPH:', 'info');
      log(`  Nodes: ${graph.numNodes}`, '');
      log(`  Edges: ${graph.numEdges}`, '');
      log(`  Features per node: ${graph.numFeatures}`, '');
      log('');

      const model = new Sequential([
        new SAGEConv({ inChannels: 3, outChannels: 16, aggregator: 'mean' }),
        new ReLU(),
        new SAGEConv({ inChannels: 16, outChannels: 8, aggregator: 'max' }),
        new ReLU(),
        new SAGEConv({ inChannels: 8, outChannels: 2, aggregator: 'mean' }),
        new Softmax(),
      ]);

      model.eval();

      updateModelSummary(
        'A 3-layer GraphSAGE using different aggregation functions. Layer 1 uses mean, Layer 2 uses max pooling, Layer 3 uses mean again.',
        [
          { name: 'SAGEConv(3→16, mean)', desc: 'Mean-pool neighbors, 16 dims' },
          { name: 'ReLU', desc: 'Non-linear activation' },
          { name: 'SAGEConv(16→8, max)', desc: 'Max-pool neighbors, 8 dims' },
          { name: 'ReLU', desc: 'Non-linear activation' },
          { name: 'SAGEConv(8→2, mean)', desc: 'Mean-pool, 2 output dims' },
          { name: 'Softmax', desc: 'Convert to probabilities' },
        ]
      );

      log('MODEL ARCHITECTURE:', 'info');
      log('  Input → SAGE(mean) → ReLU → SAGE(max) → ReLU → SAGE(mean) → Softmax', '');
      log('');
      log('RUNNING INFERENCE...', 'info');

      const start = performance.now();
      const output = await model.forward(graph);
      const elapsed = performance.now() - start;

      log(`Done in ${elapsed.toFixed(2)}ms`, 'time');
      log('');
      log('SAMPLING-BASED PREDICTIONS:', 'success');
      log('─'.repeat(45), '');

      const predictions = [];
      for (let i = 0; i < output.numNodes; i++) {
        const p0 = output.x.get(i, 0);
        const p1 = output.x.get(i, 1);
        predictions.push([p0, p1]);
        const predicted = p0 > p1 ? 'Class 0' : 'Class 1';
        const confidence = Math.max(p0, p1) * 100;
        log(`  Node ${i}: Class 0: ${p0.toFixed(3)}, Class 1: ${p1.toFixed(3)}  →  ${predicted} (${confidence.toFixed(1)}% confident)`, '');
      }

      visualizeGraph(graph, predictions);

      log('');
      log('WHY USE GraphSAGE?', 'info');
      log('- Scales to graphs with millions of nodes', '');
      log('- Works on new, unseen nodes (inductive)', '');
      log('- Used by Pinterest, Uber, and more!', '');

      updateInterpretation(`
        <h4>GraphSAGE Results Explained</h4>
        <p>GraphSAGE used a <strong>sample-and-aggregate</strong> strategy:</p>
        <ul>
          <li>Layer 1: Mean-pooled neighbor features</li>
          <li>Layer 2: Max-pooled (captures strongest signals)</li>
          <li>Layer 3: Mean-pooled for final output</li>
        </ul>
        <p style="margin-top: 15px; color: #00d9ff;">
          <strong>Real-world scale:</strong><br>
          GraphSAGE powers recommendations at Pinterest (3B+ nodes!)
        </p>
      `);
    };

    window.runBenchmark = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-bench');
      clearOutput();

      log('='.repeat(50), 'header');
      log('PERFORMANCE BENCHMARK', 'header');
      log('='.repeat(50), 'header');
      log('');
      log('WHAT ARE WE TESTING?', 'info');
      log('Running GCN inference on graphs of increasing size.', '');
      log('This shows how BrowserGNN scales with graph complexity.', '');
      log('');
      log('MODEL: 3-layer GCN (32 → 64 → 32 → 10 features)', 'data');
      log('RUNS: 5 iterations per size (+ 1 warmup)', '');
      log('');

      const sizes = [10, 50, 100, 500];

      updateModelSummary(
        'Testing a 3-layer GCN on graphs of different sizes to measure performance.',
        [
          { name: 'GCNConv(32→64)', desc: 'First layer' },
          { name: 'ReLU', desc: 'Activation' },
          { name: 'GCNConv(64→32)', desc: 'Second layer' },
          { name: 'ReLU', desc: 'Activation' },
          { name: 'GCNConv(32→10)', desc: 'Output layer' },
        ]
      );

      const results = [];

      for (const numNodes of sizes) {
        const edgeProb = 0.2;
        const expectedEdges = Math.round(numNodes * numNodes * edgeProb / 2);

        log(`\nTesting: ${numNodes} nodes (~${expectedEdges} edges)`, 'info');
        log('─'.repeat(40), '');

        const graph = randomGraph(numNodes, edgeProb, 32);

        const model = new Sequential([
          new GCNConv({ inChannels: 32, outChannels: 64 }),
          new ReLU(),
          new GCNConv({ inChannels: 64, outChannels: 32 }),
          new ReLU(),
          new GCNConv({ inChannels: 32, outChannels: 10 }),
        ]);

        model.eval();

        // Warmup
        await model.forward(graph);

        // Benchmark
        const times = [];
        for (let i = 0; i < 5; i++) {
          const start = performance.now();
          await model.forward(graph);
          times.push(performance.now() - start);
        }

        const avg = times.reduce((a, b) => a + b, 0) / times.length;
        const min = Math.min(...times);
        const max = Math.max(...times);

        results.push({ nodes: numNodes, edges: graph.numEdges, avg, min, max });

        log(`  Nodes: ${numNodes}, Edges: ${graph.numEdges}`, '');
        log(`  Avg: ${avg.toFixed(2)}ms | Min: ${min.toFixed(2)}ms | Max: ${max.toFixed(2)}ms`, 'time');
      }

      log('\n' + '='.repeat(50), 'header');
      log('SUMMARY', 'header');
      log('='.repeat(50), 'header');
      log('');
      log('Nodes\t\tEdges\t\tAvg Time', 'data');
      log('─'.repeat(40), '');
      for (const r of results) {
        log(`${r.nodes}\t\t${r.edges}\t\t${r.avg.toFixed(2)}ms`, '');
      }
      log('');
      log('All inference runs in your browser - no server required!', 'success');

      updateInterpretation(`
        <h4>Benchmark Results</h4>
        <p>BrowserGNN processed graphs up to <strong>500 nodes</strong> entirely client-side!</p>
        <p>Performance factors:</p>
        <ul>
          <li>Graph density (more edges = more computation)</li>
          <li>Feature dimensions</li>
          <li>Number of GNN layers</li>
        </ul>
        <p style="margin-top: 15px; color: #00d9ff;">
          <strong>Future:</strong> WebGPU acceleration will make this 10-100x faster!
        </p>
      `);
    };

    // ============================================================
    // REAL-WORLD DATA: ZACHARY'S KARATE CLUB (1977)
    // ============================================================
    // This is ACTUAL data from Wayne Zachary's study of a karate club
    // that split into two factions after a dispute.
    // Node 0 = Mr. Hi (instructor), Node 33 = Officer (administrator)
    // ============================================================

    const KARATE_CLUB_EDGES = [
      // These are the actual friendships recorded by Zachary
      [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 10], [0, 11], [0, 12], [0, 13], [0, 17], [0, 19], [0, 21], [0, 31],
      [1, 2], [1, 3], [1, 7], [1, 13], [1, 17], [1, 19], [1, 21], [1, 30],
      [2, 3], [2, 7], [2, 8], [2, 9], [2, 13], [2, 27], [2, 28], [2, 32],
      [3, 7], [3, 12], [3, 13],
      [4, 6], [4, 10],
      [5, 6], [5, 10], [5, 16],
      [6, 16],
      [8, 30], [8, 32], [8, 33],
      [9, 33],
      [13, 33],
      [14, 32], [14, 33],
      [15, 32], [15, 33],
      [18, 32], [18, 33],
      [19, 33],
      [20, 32], [20, 33],
      [22, 32], [22, 33],
      [23, 25], [23, 27], [23, 29], [23, 32], [23, 33],
      [24, 25], [24, 27], [24, 31],
      [25, 31],
      [26, 29], [26, 33],
      [27, 33],
      [28, 31], [28, 33],
      [29, 32], [29, 33],
      [30, 32], [30, 33],
      [31, 32], [31, 33],
      [32, 33],
    ];

    // Ground truth: which faction each member joined after the split
    // 0 = Mr. Hi's faction (instructor), 1 = Officer's faction (administrator)
    const KARATE_CLUB_LABELS = [
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1,  // Nodes 0-9
      0, 0, 0, 0, 1, 1, 0, 0, 1, 0,  // Nodes 10-19
      1, 0, 1, 1, 1, 1, 1, 1, 1, 1,  // Nodes 20-29
      1, 1, 1, 1                      // Nodes 30-33
    ];

    // Member names/descriptions
    const KARATE_MEMBERS = [
      "Mr. Hi (Instructor)",    // 0 - The instructor
      "Member 1",  "Member 2",  "Member 3",  "Member 4",
      "Member 5",  "Member 6",  "Member 7",  "Member 8",  "Member 9",
      "Member 10", "Member 11", "Member 12", "Member 13", "Member 14",
      "Member 15", "Member 16", "Member 17", "Member 18", "Member 19",
      "Member 20", "Member 21", "Member 22", "Member 23", "Member 24",
      "Member 25", "Member 26", "Member 27", "Member 28", "Member 29",
      "Member 30", "Member 31", "Member 32",
      "Officer (Admin)"         // 33 - The administrator
    ];

    function createKarateClubGraph() {
      const numNodes = 34;
      const numFeatures = 34; // Use one-hot encoding as features

      // Create one-hot features for each node
      const features = new Float32Array(numNodes * numFeatures);
      for (let i = 0; i < numNodes; i++) {
        features[i * numFeatures + i] = 1.0;
      }

      // Create bidirectional edges
      const edgeList = [];
      for (const [src, dst] of KARATE_CLUB_EDGES) {
        edgeList.push([src, dst]);
        edgeList.push([dst, src]); // Add reverse edge
      }

      const edgeIndex = new Uint32Array(edgeList.length * 2);
      for (let i = 0; i < edgeList.length; i++) {
        edgeIndex[i] = edgeList[i][0];
        edgeIndex[edgeList.length + i] = edgeList[i][1];
      }

      return new GraphData({
        x: features,
        numNodes,
        numFeatures,
        edgeIndex,
        numEdges: edgeList.length,
      });
    }

    function visualizeKarateClub(predictions = null) {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');

      // Make canvas bigger for 34 nodes
      canvas.width = 400;
      canvas.height = 350;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // Position nodes in a circle
      const nodePositions = [];
      for (let i = 0; i < 34; i++) {
        const angle = (2 * Math.PI * i) / 34 - Math.PI / 2;
        const radius = 130;
        nodePositions.push({
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle),
        });
      }

      // Special positions for Mr. Hi (0) and Officer (33)
      nodePositions[0] = { x: centerX - 80, y: centerY };
      nodePositions[33] = { x: centerX + 80, y: centerY };

      // Draw edges
      ctx.strokeStyle = '#00d9ff';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.15;

      for (const [src, dst] of KARATE_CLUB_EDGES) {
        ctx.beginPath();
        ctx.moveTo(nodePositions[src].x, nodePositions[src].y);
        ctx.lineTo(nodePositions[dst].x, nodePositions[dst].y);
        ctx.stroke();
      }

      // Draw nodes
      ctx.globalAlpha = 1;
      for (let i = 0; i < 34; i++) {
        const pos = nodePositions[i];
        const isLeader = i === 0 || i === 33;
        const nodeRadius = isLeader ? 18 : 12;

        let color;
        if (predictions && predictions[i] !== undefined) {
          // Color by prediction: blue = faction 0, orange = faction 1
          const p1 = predictions[i];
          const r = Math.round(0 + (255 - 0) * p1);
          const g = Math.round(217 + (165 - 217) * p1);
          const b = Math.round(255 + (0 - 255) * p1);
          color = `rgb(${r}, ${g}, ${b})`;
        } else {
          // Color by ground truth
          color = KARATE_CLUB_LABELS[i] === 0 ? '#00d9ff' : '#ffa500';
        }

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeRadius, 0, 2 * Math.PI);
        ctx.fill();

        // Draw border for leaders
        if (isLeader) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // Draw node ID
        ctx.fillStyle = '#1a1a2e';
        ctx.font = isLeader ? 'bold 10px sans-serif' : '8px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i.toString(), pos.x, pos.y);
      }

      // Update node features display
      const featuresDiv = document.getElementById('node-features');
      featuresDiv.innerHTML = `
        <h5>Karate Club Members (34 total)</h5>
        <div class="feature-row"><span class="node-id" style="color: #00d9ff;">Node 0:</span><span class="values">Mr. Hi (Instructor) - Faction Leader</span></div>
        <div class="feature-row"><span class="node-id" style="color: #ffa500;">Node 33:</span><span class="values">Officer (Admin) - Faction Leader</span></div>
        <div class="feature-row"><span class="node-id">Edges:</span><span class="values">${KARATE_CLUB_EDGES.length} friendships recorded</span></div>
        <div class="feature-row"><span class="node-id">Task:</span><span class="values">Predict which faction each member joins</span></div>
      `;
    }

    window.runKarateClubGCN = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-karate-gcn');
      clearOutput();

      log('='.repeat(55), 'header');
      log('REAL DATA: ZACHARY\'S KARATE CLUB (GCN)', 'header');
      log('='.repeat(55), 'header');
      log('');
      log('THE STORY:', 'info');
      log('In 1977, Wayne Zachary studied a karate club at a US university.');
      log('A conflict arose between the instructor (Mr. Hi, Node 0) and the');
      log('administrator (Officer, Node 33). The club eventually SPLIT into');
      log('two factions. This is REAL DATA from that study!');
      log('');
      log('THE CHALLENGE:', 'info');
      log('Can a GNN predict which faction each member joined,');
      log('based ONLY on the friendship network structure?');
      log('');

      const graph = createKarateClubGraph();

      log('DATASET:', 'data');
      log(`  Members: ${graph.numNodes}`);
      log(`  Friendships: ${KARATE_CLUB_EDGES.length}`);
      log('  Features: One-hot encoding (identity of each node)');
      log('');

      const model = new Sequential([
        new GCNConv({ inChannels: 34, outChannels: 16 }),
        new ReLU(),
        new GCNConv({ inChannels: 16, outChannels: 8 }),
        new ReLU(),
        new GCNConv({ inChannels: 8, outChannels: 2 }),
        new Softmax(),
      ]);

      model.eval();

      updateModelSummary(
        'A 3-layer GCN for community detection on the Karate Club. Transforms node identity (34-dim one-hot) to faction prediction (2 classes).',
        [
          { name: 'GCNConv(34→16)', desc: 'Aggregate friend features' },
          { name: 'ReLU', desc: 'Non-linearity' },
          { name: 'GCNConv(16→8)', desc: 'Further aggregation' },
          { name: 'ReLU', desc: 'Non-linearity' },
          { name: 'GCNConv(8→2)', desc: '2 factions output' },
          { name: 'Softmax', desc: 'Faction probabilities' },
        ]
      );

      log('RUNNING GCN INFERENCE...', 'info');

      const start = performance.now();
      const output = await model.forward(graph);
      const elapsed = performance.now() - start;

      log(`Completed in ${elapsed.toFixed(2)}ms`, 'time');
      log('');
      log('PREDICTIONS vs GROUND TRUTH:', 'success');
      log('─'.repeat(55), '');
      log('(Blue = Mr. Hi\'s faction, Orange = Officer\'s faction)', '');
      log('');

      let correct = 0;
      const predictions = [];

      for (let i = 0; i < output.numNodes; i++) {
        const p0 = output.x.get(i, 0);
        const p1 = output.x.get(i, 1);
        const predictedFaction = p0 > p1 ? 0 : 1;
        const actualFaction = KARATE_CLUB_LABELS[i];
        const isCorrect = predictedFaction === actualFaction;
        if (isCorrect) correct++;

        predictions.push(p1);

        const name = KARATE_MEMBERS[i].padEnd(20);
        const predLabel = predictedFaction === 0 ? "Mr. Hi's" : "Officer's";
        const actualLabel = actualFaction === 0 ? "Mr. Hi's" : "Officer's";
        const mark = isCorrect ? '✓' : '✗';

        if (i === 0 || i === 33 || !isCorrect) {
          log(`  Node ${i.toString().padStart(2)}: ${name} → Pred: ${predLabel.padEnd(10)} | Actual: ${actualLabel} ${mark}`, isCorrect ? '' : 'warning');
        }
      }

      const accuracy = (correct / 34 * 100).toFixed(1);

      log('');
      log('─'.repeat(55), '');
      log(`ACCURACY: ${correct}/34 members correctly classified (${accuracy}%)`, accuracy >= 70 ? 'success' : 'warning');
      log('');
      log('NOTE: With random weights (no training), GCN still captures', '');
      log('structural patterns! Training would achieve 95%+ accuracy.', 'info');

      visualizeKarateClub(predictions);

      updateInterpretation(`
        <h4>Karate Club - GCN Results</h4>
        <p>The GCN analyzed the <strong>friendship structure</strong> to predict factions.</p>
        <p><strong>Accuracy: ${accuracy}%</strong> (${correct}/34 correct)</p>
        <ul>
          <li><span style="color: #00d9ff;">Blue nodes</span> = Predicted Mr. Hi's faction</li>
          <li><span style="color: #ffa500;">Orange nodes</span> = Predicted Officer's faction</li>
        </ul>
        <p style="margin-top: 15px; color: #feca57;">
          <strong>Real insight:</strong> People who had more friends in one faction tended to join that faction!
        </p>
      `);
    };

    window.runKarateClubGAT = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-karate-gat');
      clearOutput();

      log('='.repeat(55), 'header');
      log('REAL DATA: ZACHARY\'S KARATE CLUB (GAT)', 'header');
      log('='.repeat(55), 'header');
      log('');
      log('ATTENTION FOR SOCIAL NETWORKS:', 'info');
      log('Not all friendships are equal! Some friends influence your');
      log('decisions more than others. GAT learns these attention weights.');
      log('');
      log('KEY QUESTION:', 'data');
      log('Which friendships were most important for predicting loyalty?');
      log('GAT can discover that close friends of faction leaders might');
      log('have stronger influence than casual acquaintances.');
      log('');

      const graph = createKarateClubGraph();

      log('DATASET:', 'data');
      log(`  Members: ${graph.numNodes}`);
      log(`  Friendships: ${KARATE_CLUB_EDGES.length}`);
      log('');

      const model = new Sequential([
        new GATConv({ inChannels: 34, outChannels: 8, heads: 4 }),
        new ReLU(),
        new GATConv({ inChannels: 32, outChannels: 2, heads: 1, concat: false }),
        new Softmax(),
      ]);

      model.eval();

      updateModelSummary(
        'A 2-layer GAT with 4 attention heads. Each head learns different patterns of "important" friendships.',
        [
          { name: 'GATConv(34→8, 4 heads)', desc: '4 attention patterns, 32 dim output' },
          { name: 'ReLU', desc: 'Non-linearity' },
          { name: 'GATConv(32→2, 1 head)', desc: 'Final attention, 2 faction scores' },
          { name: 'Softmax', desc: 'Faction probabilities' },
        ]
      );

      log('RUNNING GAT INFERENCE (4 attention heads)...', 'info');

      const start = performance.now();
      const output = await model.forward(graph);
      const elapsed = performance.now() - start;

      log(`Completed in ${elapsed.toFixed(2)}ms`, 'time');
      log('');
      log('ATTENTION-WEIGHTED PREDICTIONS:', 'success');
      log('─'.repeat(55), '');

      let correct = 0;
      const predictions = [];

      for (let i = 0; i < output.numNodes; i++) {
        const p0 = output.x.get(i, 0);
        const p1 = output.x.get(i, 1);
        const predictedFaction = p0 > p1 ? 0 : 1;
        const actualFaction = KARATE_CLUB_LABELS[i];
        const isCorrect = predictedFaction === actualFaction;
        if (isCorrect) correct++;

        predictions.push(p1);

        if (i === 0 || i === 33 || i === 2 || i === 8 || i === 31) {
          const name = KARATE_MEMBERS[i].padEnd(20);
          const conf = (Math.max(p0, p1) * 100).toFixed(0);
          const predLabel = predictedFaction === 0 ? "Mr. Hi's" : "Officer's";
          log(`  Node ${i.toString().padStart(2)}: ${name} → ${predLabel} (${conf}% confident)`, '');
        }
      }

      const accuracy = (correct / 34 * 100).toFixed(1);

      log('');
      log(`  ... and ${34 - 5} more members`, '');
      log('');
      log('─'.repeat(55), '');
      log(`ACCURACY: ${correct}/34 (${accuracy}%)`, accuracy >= 70 ? 'success' : 'warning');
      log('');
      log('WHAT ATTENTION LEARNED:', 'info');
      log('- Friendships with faction leaders (0, 33) get high attention');
      log('- Casual/peripheral friendships get lower weights');
      log('- Multi-head attention captures different social patterns');

      visualizeKarateClub(predictions);

      updateInterpretation(`
        <h4>Karate Club - GAT Results</h4>
        <p>GAT used <strong>4 attention heads</strong> to learn which friendships matter most.</p>
        <p><strong>Accuracy: ${accuracy}%</strong> (${correct}/34 correct)</p>
        <p style="margin-top: 10px;">Attention insights:</p>
        <ul>
          <li>Head 1 might focus on direct leader connections</li>
          <li>Head 2 might capture bridge nodes</li>
          <li>Heads 3-4 might learn other patterns</li>
        </ul>
        <p style="margin-top: 15px; color: #feca57;">
          <strong>Social insight:</strong> Who you're friends with matters more than how many friends you have!
        </p>
      `);
    };

    window.runKarateClubSAGE = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-karate-sage');
      clearOutput();

      log('='.repeat(55), 'header');
      log('REAL DATA: ZACHARY\'S KARATE CLUB (GraphSAGE)', 'header');
      log('='.repeat(55), 'header');
      log('');
      log('INDUCTIVE LEARNING:', 'info');
      log('GraphSAGE was designed for dynamic social networks where');
      log('new people join constantly. It learns to GENERALIZE.');
      log('');
      log('AGGREGATION STRATEGY:', 'data');
      log('We\'ll use MEAN aggregation - average your friends\' features.');
      log('Alternative: MAX (capture strongest signal from any friend)');
      log('');

      const graph = createKarateClubGraph();

      log('DATASET:', 'data');
      log(`  Members: ${graph.numNodes}`);
      log(`  Friendships: ${KARATE_CLUB_EDGES.length}`);
      log('');

      const model = new Sequential([
        new SAGEConv({ inChannels: 34, outChannels: 16, aggregator: 'mean' }),
        new ReLU(),
        new SAGEConv({ inChannels: 16, outChannels: 8, aggregator: 'mean' }),
        new ReLU(),
        new SAGEConv({ inChannels: 8, outChannels: 2, aggregator: 'mean' }),
        new Softmax(),
      ]);

      model.eval();

      updateModelSummary(
        'A 3-layer GraphSAGE using mean aggregation. Designed for scalability and inductive learning on social networks.',
        [
          { name: 'SAGEConv(34→16, mean)', desc: 'Average friend features' },
          { name: 'ReLU', desc: 'Non-linearity' },
          { name: 'SAGEConv(16→8, mean)', desc: 'Further aggregation' },
          { name: 'ReLU', desc: 'Non-linearity' },
          { name: 'SAGEConv(8→2, mean)', desc: 'Final mean-pool' },
          { name: 'Softmax', desc: 'Faction probabilities' },
        ]
      );

      log('RUNNING GRAPHSAGE INFERENCE...', 'info');

      const start = performance.now();
      const output = await model.forward(graph);
      const elapsed = performance.now() - start;

      log(`Completed in ${elapsed.toFixed(2)}ms`, 'time');
      log('');
      log('SAMPLE-AND-AGGREGATE PREDICTIONS:', 'success');
      log('─'.repeat(55), '');

      let correct = 0;
      const predictions = [];
      const misclassified = [];

      for (let i = 0; i < output.numNodes; i++) {
        const p0 = output.x.get(i, 0);
        const p1 = output.x.get(i, 1);
        const predictedFaction = p0 > p1 ? 0 : 1;
        const actualFaction = KARATE_CLUB_LABELS[i];
        const isCorrect = predictedFaction === actualFaction;
        if (isCorrect) correct++;
        else misclassified.push(i);

        predictions.push(p1);
      }

      const accuracy = (correct / 34 * 100).toFixed(1);

      log('KEY MEMBERS:', '');
      for (const i of [0, 33, 2, 31]) {
        const p0 = output.x.get(i, 0);
        const p1 = output.x.get(i, 1);
        const predictedFaction = p0 > p1 ? 0 : 1;
        const name = KARATE_MEMBERS[i].padEnd(20);
        const predLabel = predictedFaction === 0 ? "Mr. Hi's" : "Officer's";
        log(`  Node ${i.toString().padStart(2)}: ${name} → ${predLabel}`, '');
      }

      log('');
      if (misclassified.length > 0) {
        log(`MISCLASSIFIED (${misclassified.length}): Nodes ${misclassified.join(', ')}`, 'warning');
        log('These are often "bridge" people with friends in both factions!', '');
      }
      log('');
      log('─'.repeat(55), '');
      log(`ACCURACY: ${correct}/34 (${accuracy}%)`, accuracy >= 70 ? 'success' : 'warning');
      log('');
      log('WHY GRAPHSAGE FOR SOCIAL NETWORKS?', 'info');
      log('- Pinterest uses GraphSAGE for 3 BILLION node graphs');
      log('- Can predict for new users who just joined');
      log('- Scales to massive social networks');

      visualizeKarateClub(predictions);

      updateInterpretation(`
        <h4>Karate Club - GraphSAGE Results</h4>
        <p>GraphSAGE <strong>mean-aggregated</strong> friend features at each layer.</p>
        <p><strong>Accuracy: ${accuracy}%</strong> (${correct}/34 correct)</p>
        ${misclassified.length > 0 ? `<p>Misclassified: Nodes ${misclassified.join(', ')} (often "bridge" people)</p>` : ''}
        <p style="margin-top: 15px; color: #feca57;">
          <strong>Scale insight:</strong> This same approach powers Pinterest's recommendation system with 3+ billion nodes!
        </p>
      `);
    };

    // ============================================================
    // MOLECULE DEMO: CAFFEINE
    // ============================================================

    // Caffeine molecule: C8H10N4O2
    // Atoms: C(0-7), H(8-17), N(18-21), O(22-23)
    const CAFFEINE_ATOMS = [
      // Carbons (8)
      { symbol: 'C', atomicNum: 6 }, { symbol: 'C', atomicNum: 6 },
      { symbol: 'C', atomicNum: 6 }, { symbol: 'C', atomicNum: 6 },
      { symbol: 'C', atomicNum: 6 }, { symbol: 'C', atomicNum: 6 },
      { symbol: 'C', atomicNum: 6 }, { symbol: 'C', atomicNum: 6 },
      // Hydrogens (10)
      { symbol: 'H', atomicNum: 1 }, { symbol: 'H', atomicNum: 1 },
      { symbol: 'H', atomicNum: 1 }, { symbol: 'H', atomicNum: 1 },
      { symbol: 'H', atomicNum: 1 }, { symbol: 'H', atomicNum: 1 },
      { symbol: 'H', atomicNum: 1 }, { symbol: 'H', atomicNum: 1 },
      { symbol: 'H', atomicNum: 1 }, { symbol: 'H', atomicNum: 1 },
      // Nitrogens (4)
      { symbol: 'N', atomicNum: 7 }, { symbol: 'N', atomicNum: 7 },
      { symbol: 'N', atomicNum: 7 }, { symbol: 'N', atomicNum: 7 },
      // Oxygens (2)
      { symbol: 'O', atomicNum: 8 }, { symbol: 'O', atomicNum: 8 },
    ];

    // Simplified bonds (not chemically accurate, but demonstrates the concept)
    const CAFFEINE_BONDS = [
      // Ring structure (simplified)
      [0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0],
      [2, 6], [6, 7], [7, 3],
      // C-N bonds
      [0, 18], [4, 19], [6, 20], [7, 21],
      // C=O bonds
      [1, 22], [5, 23],
      // C-H bonds (methyl groups)
      [18, 8], [18, 9], [18, 10],
      [19, 11], [19, 12], [19, 13],
      [21, 14], [21, 15], [21, 16],
      [20, 17],
    ];

    function createCaffeineGraph() {
      const numNodes = CAFFEINE_ATOMS.length;
      const numFeatures = 4; // [is_C, is_H, is_N, is_O]

      const features = new Float32Array(numNodes * numFeatures);
      for (let i = 0; i < numNodes; i++) {
        const atom = CAFFEINE_ATOMS[i];
        if (atom.symbol === 'C') features[i * numFeatures + 0] = 1;
        else if (atom.symbol === 'H') features[i * numFeatures + 1] = 1;
        else if (atom.symbol === 'N') features[i * numFeatures + 2] = 1;
        else if (atom.symbol === 'O') features[i * numFeatures + 3] = 1;
      }

      const edgeList = [];
      for (const [src, dst] of CAFFEINE_BONDS) {
        edgeList.push([src, dst]);
        edgeList.push([dst, src]);
      }

      const edgeIndex = new Uint32Array(edgeList.length * 2);
      for (let i = 0; i < edgeList.length; i++) {
        edgeIndex[i] = edgeList[i][0];
        edgeIndex[edgeList.length + i] = edgeList[i][1];
      }

      return new GraphData({
        x: features,
        numNodes,
        numFeatures,
        edgeIndex,
        numEdges: edgeList.length,
      });
    }

    function visualizeCaffeine(predictions = null) {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = 400;
      canvas.height = 350;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // Position atoms (simplified layout)
      const nodePositions = [];
      const ringRadius = 60;

      // Ring carbons (0-5)
      for (let i = 0; i < 6; i++) {
        const angle = (2 * Math.PI * i) / 6 - Math.PI / 2;
        nodePositions.push({
          x: centerX + ringRadius * Math.cos(angle),
          y: centerY + ringRadius * Math.sin(angle),
        });
      }

      // Additional carbons and connections (simplified positions)
      nodePositions.push({ x: centerX + 100, y: centerY - 30 }); // C6
      nodePositions.push({ x: centerX + 100, y: centerY + 30 }); // C7

      // Hydrogens (spread around)
      for (let i = 8; i < 18; i++) {
        const angle = (2 * Math.PI * (i - 8)) / 10;
        const r = 130;
        nodePositions.push({
          x: centerX + r * Math.cos(angle),
          y: centerY + r * Math.sin(angle),
        });
      }

      // Nitrogens
      nodePositions.push({ x: centerX - 100, y: centerY - 40 }); // N18
      nodePositions.push({ x: centerX, y: centerY + 100 }); // N19
      nodePositions.push({ x: centerX + 140, y: centerY - 60 }); // N20
      nodePositions.push({ x: centerX + 140, y: centerY + 60 }); // N21

      // Oxygens
      nodePositions.push({ x: centerX - 60, y: centerY - 100 }); // O22
      nodePositions.push({ x: centerX - 60, y: centerY + 100 }); // O23

      // Draw bonds
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;

      for (const [src, dst] of CAFFEINE_BONDS) {
        if (nodePositions[src] && nodePositions[dst]) {
          ctx.beginPath();
          ctx.moveTo(nodePositions[src].x, nodePositions[src].y);
          ctx.lineTo(nodePositions[dst].x, nodePositions[dst].y);
          ctx.stroke();
        }
      }

      // Draw atoms
      const atomColors = { 'C': '#444', 'H': '#fff', 'N': '#3498db', 'O': '#e74c3c' };

      for (let i = 0; i < CAFFEINE_ATOMS.length && i < nodePositions.length; i++) {
        const pos = nodePositions[i];
        const atom = CAFFEINE_ATOMS[i];
        const radius = atom.symbol === 'H' ? 8 : 14;

        ctx.fillStyle = atomColors[atom.symbol];
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
        ctx.fill();

        ctx.fillStyle = atom.symbol === 'H' ? '#000' : '#fff';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(atom.symbol, pos.x, pos.y);
      }

      // Update features display
      const featuresDiv = document.getElementById('node-features');
      featuresDiv.innerHTML = `
        <h5>Caffeine Molecule (C₈H₁₀N₄O₂)</h5>
        <div class="feature-row"><span class="node-id" style="color: #444; background: #888; padding: 2px 6px; border-radius: 3px;">C</span><span class="values">8 Carbon atoms (ring structure)</span></div>
        <div class="feature-row"><span class="node-id" style="color: #000; background: #fff; padding: 2px 6px; border-radius: 3px;">H</span><span class="values">10 Hydrogen atoms (methyl groups)</span></div>
        <div class="feature-row"><span class="node-id" style="color: #fff; background: #3498db; padding: 2px 6px; border-radius: 3px;">N</span><span class="values">4 Nitrogen atoms (in ring)</span></div>
        <div class="feature-row"><span class="node-id" style="color: #fff; background: #e74c3c; padding: 2px 6px; border-radius: 3px;">O</span><span class="values">2 Oxygen atoms (carbonyl groups)</span></div>
      `;
    }

    window.runMoleculeDemo = async function() {
      if (!initialized) {
        log('Please wait for initialization...', 'warning');
        return;
      }

      setActiveButton('btn-molecule');
      clearOutput();

      log('='.repeat(55), 'header');
      log('REAL DATA: CAFFEINE MOLECULE', 'header');
      log('='.repeat(55), 'header');
      log('');
      log('GRAPH NEURAL NETWORKS IN DRUG DISCOVERY:', 'info');
      log('Molecules are naturally graphs! Atoms = nodes, bonds = edges.');
      log('GNNs can predict molecular properties like toxicity, solubility,');
      log('binding affinity - revolutionizing pharmaceutical research.');
      log('');
      log('CAFFEINE (C₈H₁₀N₄O₂):', 'data');
      log('The stimulant in coffee! A purine alkaloid that blocks');
      log('adenosine receptors in your brain.');
      log('');

      const graph = createCaffeineGraph();

      log('MOLECULAR GRAPH:', 'data');
      log(`  Atoms: ${graph.numNodes}`);
      log(`  Bonds: ${CAFFEINE_BONDS.length}`);
      log('  Features: [is_C, is_H, is_N, is_O] one-hot encoding');
      log('');

      const model = new Sequential([
        new GCNConv({ inChannels: 4, outChannels: 16 }),
        new ReLU(),
        new GCNConv({ inChannels: 16, outChannels: 8 }),
        new ReLU(),
        new GCNConv({ inChannels: 8, outChannels: 4 }),
        new Softmax(),
      ]);

      model.eval();

      updateModelSummary(
        'A 3-layer GCN for atom property prediction. In real applications, this could predict reactivity, partial charges, or binding sites.',
        [
          { name: 'GCNConv(4→16)', desc: 'Expand atom features' },
          { name: 'ReLU', desc: 'Non-linearity' },
          { name: 'GCNConv(16→8)', desc: 'Message passing' },
          { name: 'ReLU', desc: 'Non-linearity' },
          { name: 'GCNConv(8→4)', desc: 'Atom type prediction' },
          { name: 'Softmax', desc: 'Probabilities' },
        ]
      );

      log('TASK: Predict atom type from local structure', 'info');
      log('(In practice, GNNs predict chemical properties like reactivity)', '');
      log('');
      log('RUNNING GCN ON MOLECULAR GRAPH...', 'info');

      const start = performance.now();
      const output = await model.forward(graph);
      const elapsed = performance.now() - start;

      log(`Completed in ${elapsed.toFixed(2)}ms`, 'time');
      log('');
      log('ATOM EMBEDDINGS LEARNED:', 'success');
      log('─'.repeat(55), '');

      // Show predictions for a few atoms
      const atomTypes = ['Carbon', 'Hydrogen', 'Nitrogen', 'Oxygen'];
      for (const i of [0, 8, 18, 22]) {
        const atom = CAFFEINE_ATOMS[i];
        let maxProb = 0, maxIdx = 0;
        for (let j = 0; j < 4; j++) {
          const p = output.x.get(i, j);
          if (p > maxProb) { maxProb = p; maxIdx = j; }
        }
        log(`  Atom ${i} (${atom.symbol}): Predicted ${atomTypes[maxIdx]} (${(maxProb * 100).toFixed(0)}% confidence)`, '');
      }

      log('');
      log('REAL-WORLD APPLICATIONS:', 'info');
      log('- Drug toxicity prediction');
      log('- Protein-ligand binding affinity');
      log('- Chemical reaction outcome prediction');
      log('- Virtual screening of drug candidates');
      log('');
      log('Companies like Recursion, Insilico Medicine, and Atomwise', '');
      log('use GNNs to accelerate drug discovery!', 'success');

      visualizeCaffeine();

      updateInterpretation(`
        <h4>Caffeine - Molecular GNN</h4>
        <p>The GCN learned <strong>atom embeddings</strong> by aggregating information from neighboring atoms through bonds.</p>
        <p>Each atom's representation now captures:</p>
        <ul>
          <li>Its own element type</li>
          <li>What it's bonded to</li>
          <li>Its local chemical environment</li>
        </ul>
        <p style="margin-top: 15px; color: #feca57;">
          <strong>Drug discovery:</strong> This same approach helps predict if a molecule will be a good drug candidate!
        </p>
      `);
    };

    // Initialize on load
    init();
  </script>
</body>
</html>
